<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-29T02:03:14.011Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Rancher搭配Harbor部署Kafka集群</title>
    <link href="http://yoursite.com/2019/07/25/%E4%BD%BF%E7%94%A8Rancher%E6%90%AD%E9%85%8DHarbor%E9%83%A8%E7%BD%B2Kafka/"/>
    <id>http://yoursite.com/2019/07/25/使用Rancher搭配Harbor部署Kafka/</id>
    <published>2019-07-25T08:20:19.000Z</published>
    <updated>2019-07-29T02:03:14.011Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>Kafka是没有一个官方的镜像的，但是有一个star比较高的个人镜像，是<code>wurstmeister/kafka</code>，更新的也比较频繁，所以我们就选择这个镜像：<code>docker pull wurstmeister/kafka</code>。而kafka启动依赖zookeeper，于是我们还需要<code>docker pull digitalwonderland/zookeeper</code>，然后把他俩都上传到自建的harbor仓库里。</p><p>在部署的时候，rancher会去harbor里拉取镜像，但是harbor的私有仓是需要账号密码鉴权的，于是我们就要在rancher的界面点击<code>集群</code>—&gt;<code>执行kubectl命令行</code>，然后输入对应的内容：<br><img src="/images/rancher14.png" alt="抱光妹" title="如果右上角显示连接中，那么请换一个浏览器"></p><p>其中<code>secret-name</code>：secret的名称，<code>namespace</code>：命名空间，<code>docker-server</code>：Harbor仓库地址，<code>docker-username</code>：Harbor仓库登录账号，<code>docker-password</code>：Harbor仓库登录密码，<code>docker-email</code>：邮件地址。</p><p>执行之后，三个worker就应该可以登录到harbor仓库里了。</p><h2><span id="部署zookeeper">部署zookeeper</span></h2><p>现在我们开始部署zookeeper，首先来到<code>项目/命名空间</code>，在<code>Default</code>这个项目里新建一个命名空间，比如叫shop。<br><img src="/images/rancher15.png" alt="抱光妹"></p><p>然后点击集群的下拉菜单，选择<code>default</code>:<br><img src="/images/rancher16.png" alt="抱光妹"></p><p>点击<code>部署服务</code>，填写一些基本资料：<br><img src="/images/rancher17.png" alt="抱光妹"></p><p>然后点击启动，就完事了！但是不要高兴太久，发现pod有错误，是处于<code>Unavailable</code>的状态：<br><img src="/images/rancher18.png" alt="抱光妹"></p><p>来到worker里，<code>kubectl get pods --namespace=shop</code>查看一下这几个pod的状态：<br><img src="/images/rancher19.png" alt="抱光妹"></p><p>竟然是<code>ImagePullBackOff</code>？那么除了网络问题外，就是：镜像tag不正确、镜像不存在（或者是在另一个仓库）、Kubernetes没有权限去拉那个镜像。使用<code>kubectl describe pod 对应pod名 --namespace=shop</code>查看细节，果然被拒绝了：<br><img src="/images/rancher20.png" alt="抱光妹"></p><p>后来发现犯了两个错误，第一我把secret的namespace写到了<code>default</code>这个namespace里，结果部署是在<code>shop</code>这个namespace里；第二使用<code>kubectl get secret  secret-name -o yaml</code>以及<code>echo &quot;秘钥&quot; | base64 --decode</code>发现，我的harbor IP写错了，在<code>secret</code>里写的是内网IP，结果在部署的时候，镜像填写的是外网IP，更改过来之后，就OK了！<br><img src="/images/rancher24.png" alt="抱光妹"></p><p>如果习惯使用yaml的方式去部署的话，可以直接在工作负载的地方点击<code>导入yaml</code>：<br><img src="/images/rancher23.png" alt="抱光妹"></p><p>然后复制进如下的yaml:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: zookeeper-deployment-1</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: zookeeper-1</span><br><span class="line">      name: zookeeper-1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: zookeeper-1</span><br><span class="line">        name: zookeeper-1</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: zoo1</span><br><span class="line">          image: digitalwonderland/zookeeper</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 2181</span><br><span class="line">          env:</span><br><span class="line">            - name: ZOOKEEPER_ID</span><br><span class="line">              value: &quot;1&quot;</span><br><span class="line">            - name: ZOOKEEPER_SERVER_1</span><br><span class="line">              value: zoo1</span><br><span class="line">            - name: ZOOKEEPER_SERVER_2</span><br><span class="line">              value: zoo2</span><br><span class="line">            - name: ZOOKEEPER_SERVER_3</span><br><span class="line">              value: zoo3</span><br><span class="line">---</span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: zookeeper-deployment-2</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: zookeeper-2</span><br><span class="line">      name: zookeeper-2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: zookeeper-2</span><br><span class="line">        name: zookeeper-2</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: zoo2</span><br><span class="line">          image: digitalwonderland/zookeeper</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 2181</span><br><span class="line">          env:</span><br><span class="line">            - name: ZOOKEEPER_ID</span><br><span class="line">              value: &quot;2&quot;</span><br><span class="line">            - name: ZOOKEEPER_SERVER_1</span><br><span class="line">              value: zoo1</span><br><span class="line">            - name: ZOOKEEPER_SERVER_2</span><br><span class="line">              value: zoo2</span><br><span class="line">            - name: ZOOKEEPER_SERVER_3</span><br><span class="line">              value: zoo3</span><br><span class="line">---</span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: zookeeper-deployment-3</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: zookeeper-3</span><br><span class="line">      name: zookeeper-3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: zookeeper-3</span><br><span class="line">        name: zookeeper-3</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: zoo3</span><br><span class="line">          image: digitalwonderland/zookeeper</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 2181</span><br><span class="line">          env:</span><br><span class="line">            - name: ZOOKEEPER_ID</span><br><span class="line">              value: &quot;3&quot;</span><br><span class="line">            - name: ZOOKEEPER_SERVER_1</span><br><span class="line">              value: zoo1</span><br><span class="line">            - name: ZOOKEEPER_SERVER_2</span><br><span class="line">              value: zoo2</span><br><span class="line">            - name: ZOOKEEPER_SERVER_3</span><br><span class="line">              value: zoo3</span><br></pre></td></tr></table></figure></p><p>点击提交之后，上面三个deployment就生成了，去任意的一台worker服务器里使用<code>for i in pod的名称后缀; do kubectl exec zookeeper-$i --namespace=shop /bin/bash /apache-zookeeper-3.5.5-bin/bin/zkServer.sh status ; done</code>获得结果如下：<br><img src="/images/rancher22.png" alt="抱光妹"></p><p>zk的角色都已经分配好了，至此zookeeper集群搭建完毕！</p><h2><span id="部署kafka">部署kafka</span></h2><p>还是在这个集群里，点击上面菜单栏的<code>服务发现</code>，再点击旁边的<code>导入yaml</code>，复制粘贴如下的yaml内容：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-service-1</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-service-1</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 9092</span><br><span class="line">      name: kafka-service-1</span><br><span class="line">      targetPort: 9092</span><br><span class="line">      nodePort: 30901</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: kafka-service-1</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-service-2</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-service-2</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 9092</span><br><span class="line">      name: kafka-service-2</span><br><span class="line">      targetPort: 9092</span><br><span class="line">      nodePort: 30902</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: kafka-service-2</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-service-3</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-service-3</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 9092</span><br><span class="line">      name: kafka-service-3</span><br><span class="line">      targetPort: 9092</span><br><span class="line">      nodePort: 30903</span><br><span class="line">      protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: kafka-service-3</span><br></pre></td></tr></table></figure></p><p>然后再返回工作负载里，同样进入<code>导入yaml</code>，输入如下yaml:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-deployment<span class="number">-1</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: kafka-service<span class="number">-1</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: kafka-service<span class="number">-1</span></span><br><span class="line">        app: kafka-service<span class="number">-1</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kafka<span class="number">-1</span></span><br><span class="line">        image: wurstmeister/kafka</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">9092</span></span><br><span class="line">        env:</span><br><span class="line">        - name: KAFKA_ADVERTISED_PORT</span><br><span class="line">          value: <span class="string">"9092"</span></span><br><span class="line">        - name: KAFKA_ADVERTISED_HOST_NAME</span><br><span class="line">          value: [kafka-service1的clusterIP]</span><br><span class="line">        - name: KAFKA_ZOOKEEPER_CONNECT</span><br><span class="line">          value: zoo1:<span class="number">2181</span>,zoo2:<span class="number">2181</span>,zoo3:<span class="number">2181</span></span><br><span class="line">        - name: KAFKA_BROKER_ID</span><br><span class="line">          value: <span class="string">"1"</span></span><br><span class="line">        - name: KAFKA_CREATE_TOPICS</span><br><span class="line">          value: mytopic:<span class="number">2</span>:<span class="number">1</span></span><br><span class="line">---</span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-deployment<span class="number">-2</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: kafka-service<span class="number">-2</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: kafka-service<span class="number">-2</span></span><br><span class="line">        app: kafka-service<span class="number">-2</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kafka<span class="number">-2</span></span><br><span class="line">        image: wurstmeister/kafka</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">9092</span></span><br><span class="line">        env:</span><br><span class="line">        - name: KAFKA_ADVERTISED_PORT</span><br><span class="line">          value: <span class="string">"9092"</span></span><br><span class="line">        - name: KAFKA_ADVERTISED_HOST_NAME</span><br><span class="line">          value: [kafka-service2的clusterIP]</span><br><span class="line">        - name: KAFKA_ZOOKEEPER_CONNECT</span><br><span class="line">          value: zoo1:<span class="number">2181</span>,zoo2:<span class="number">2181</span>,zoo3:<span class="number">2181</span></span><br><span class="line">        - name: KAFKA_BROKER_ID</span><br><span class="line">          value: <span class="string">"2"</span></span><br><span class="line">---</span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-deployment<span class="number">-3</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      name: kafka-service<span class="number">-3</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: kafka-service<span class="number">-3</span></span><br><span class="line">        app: kafka-service<span class="number">-3</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kafka<span class="number">-3</span></span><br><span class="line">        image: wurstmeister/kafka</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: <span class="number">9092</span></span><br><span class="line">        env:</span><br><span class="line">        - name: KAFKA_ADVERTISED_PORT</span><br><span class="line">          value: <span class="string">"9092"</span></span><br><span class="line">        - name: KAFKA_ADVERTISED_HOST_NAME</span><br><span class="line">          value: [kafka-service3的clusterIP]</span><br><span class="line">        - name: KAFKA_ZOOKEEPER_CONNECT</span><br><span class="line">          value: zoo1:<span class="number">2181</span>,zoo2:<span class="number">2181</span>,zoo3:<span class="number">2181</span></span><br><span class="line">        - name: KAFKA_BROKER_ID</span><br><span class="line">          value: <span class="string">"3"</span></span><br></pre></td></tr></table></figure></p><p>然后就会生成kafka了！我个人还是很喜欢用yaml去生成服务的。<br><img src="/images/rancher25.png" alt="抱光妹"></p><p>如果发现导入<code>yaml界面</code>卡死了，极有可能是yaml格式有问题。点击取消修改错误再提交即可。</p><h2><span id="验证kafka">验证kafka</span></h2><p>部署完了还要验证的，首先来到workers里，先使用<code>kubectl get service --all-namespaces</code>获取kafka的<code>CLUSTER-IP</code>。如下：<br><img src="/images/rancher27.png" alt="抱光妹"></p><p>然后再<code>kubectl exec -it kafkapod名称 /bin/bash --namespace=shop</code>进入到跟刚才记录IP不一样的kafka里，先<code>cd opt/kafka/bin</code>，然后<code>kafka-console-producer.sh --broker-list 任意kafka的CLUSTER-IP:9092 --topic test</code>。此时打开另一个xshell窗口，同样随机进入一个kafka的pod里，也是到<code>opt/kafka/bin</code>下之后，执行<code>kafka-console-consumer.sh --bootstrap-server 另一个kafka的CLUSTER-IP:9092 --topic test --from-beginning</code>，此时在原先窗口里输入字符，可以在第二个窗口里看到，这样就算OK了！如图：<br><img src="/images/rancher26.png" alt="抱光妹" title="两个IP地址不一样的"></p><h2><span id="部署kafka-manager">部署kafka-manager</span></h2><p>开发又提出了需求，希望安装一个kafka的可视化插件，提高办公效率。于是我就选择了kafka-manager作为插件，yaml内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-manager</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-manager</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: kafka</span><br><span class="line">    port: <span class="number">9000</span></span><br><span class="line">    targetPort: <span class="number">9000</span></span><br><span class="line">    nodePort: <span class="number">30900</span></span><br><span class="line">  selector:</span><br><span class="line">    app: kafka-manager</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: kafka-manager</span><br><span class="line">  labels:</span><br><span class="line">    app: kafka-manager</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: kafka-manager</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kafka-manager</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kafka-manager</span><br><span class="line">        image: zenko/kafka-manager:<span class="number">1.3</span><span class="number">.3</span><span class="number">.22</span></span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        ports:</span><br><span class="line">        - name: kafka-manager</span><br><span class="line">          containerPort: <span class="number">9000</span></span><br><span class="line">          protocol: TCP</span><br><span class="line">        env:</span><br><span class="line">        - name: ZK_HOSTS</span><br><span class="line">          value: <span class="string">"[zookeeper的IP]:2181"</span></span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /api/health</span><br><span class="line">            port: kafka-manager</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /api/health</span><br><span class="line">            port: kafka-manager</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: <span class="number">500</span>m</span><br><span class="line">            memory: <span class="number">512</span>Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: <span class="number">250</span>m</span><br><span class="line">            memory: <span class="number">256</span>Mi</span><br></pre></td></tr></table></figure></p><p>同样在<code>工作负载</code>—<code>导入yaml</code>里粘贴上面的yaml之后，执行一下就会看到kafka-manager的deployment生成了，如图：<br><img src="/images/rancher28.png" alt="抱光妹"></p><p>在阿里云SLB里配置对应的端口，然后在浏览器里就可以访问了，如图：<br><img src="/images/rancher29.png" alt="抱光妹"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://o-my-chenjian.com/2017/04/11/Deploy-Kafka-And-ZP-With-K8s/" target="_blank" rel="noopener">https://o-my-chenjian.com/2017/04/11/Deploy-Kafka-And-ZP-With-K8s/</a><br><a href="http://blog.yuandingit.com/2019/03/26/Practice-of-Business-Containerization-Transformation-(3)/" target="_blank" rel="noopener">http://blog.yuandingit.com/2019/03/26/Practice-of-Business-Containerization-Transformation-(3)/</a><br><a href="https://www.cnblogs.com/00986014w/p/9561901.html" target="_blank" rel="noopener">https://www.cnblogs.com/00986014w/p/9561901.html</a> （文中yaml的作者）<br><a href="https://k8smeetup.github.io/docs/tutorials/stateful-application/zookeeper/" target="_blank" rel="noopener">https://k8smeetup.github.io/docs/tutorials/stateful-application/zookeeper/</a></p>]]></content>
    
    <summary type="html">
    
      若出现了nginx失败重传，去检查一下proxy_next_upstream的配置方法
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
      <category term="rancher" scheme="http://yoursite.com/tags/rancher/"/>
    
      <category term="harbor" scheme="http://yoursite.com/tags/harbor/"/>
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>使用Rancher2.1部署k8s集群</title>
    <link href="http://yoursite.com/2019/07/25/%E4%BD%BF%E7%94%A8Rancher2-1%E9%83%A8%E7%BD%B2k8s/"/>
    <id>http://yoursite.com/2019/07/25/使用Rancher2-1部署k8s/</id>
    <published>2019-07-25T03:03:04.000Z</published>
    <updated>2019-07-25T08:04:31.929Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="rancher是个啥">rancher是个啥？</span></h2><p>Rancher是一个开源的企业级全栈化容器部署及管理平台。简单的说，就是一个可以让你通过web界面管理docker容器的平台。定位上和K8s比较接近，都是通过web界面赋予完全的docker服务编排功能。而且它自带账户权限。相比K8s没有账号管理rancher自带账号权限体系。账号可以独立创建，也可以很方便地接入ldap等账号体系，对于公司使用是一大利器。</p><p>还有一个最牛逼的就是它有一个应用商店，并且可以做到配置自用的应用商店，部署服务，很快就能搞定！</p><p>所以说在k8s势不可挡的今天，学习一下rancher还是很有必要的。哪怕你领导担心它搞不定线上业务，拿来给测试环境部署也好啊！具体rancher的优点和不足可以去看 <a href="https://blog.csdn.net/CSDN_duomaomao/article/details/78029800" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_duomaomao/article/details/78029800</a> 。</p><h2><span id="安装rancher以及创建k8s集群">安装rancher以及创建k8s集群</span></h2><p>安装rancher的方法非常简单：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=unless-stopped --name rancher-managment -p <span class="number">8080</span>:<span class="number">80</span> -p <span class="number">8443</span>:<span class="number">443</span> -v /rancher/data:/var/lib/rancher rancher/rancher:v2<span class="number">.1</span><span class="number">.6</span></span><br></pre></td></tr></table></figure></p><p>参数<code>--restart=unless-stopped</code>的意思是<code>在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</code>。</p><p>然后确认一下防火墙是否对外开放了8443和8080端口，打开浏览器输入<code>IP:8443</code>就会看到rancher的样子，自带中文版，就问你感动不感动？<br><img src="/images/rancher5.png" alt="抱光妹"></p><p>然后准备三台服务器，资料如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">名称：k8s<span class="number">-001</span>IP：<span class="string">"172.20.52.12"</span>角色：etcd+control+worker</span><br><span class="line">名称：k8s<span class="number">-002</span>IP：<span class="string">"172.20.52.11"</span>角色：worker</span><br><span class="line">名称：k8s<span class="number">-003</span>IP：<span class="string">"172.20.52.10"</span>角色：worker</span><br></pre></td></tr></table></figure></p><p>以上服务器系统均为centos7，而且与rancher网络的8443和8080端口互通。为了路径相同，个人建议在rancher买一个大一点的高效云盘，然后让这三个worker都挂载这个云盘，这样的话启动容器的时候，数据都持久化保存在云盘里。</p><p>回到rancher页面，点击<code>添加集群</code>，选择CUSTOM，然后给集群起个名儿，如果有其他的rancher成员可以管理或者访问这个集群就编辑一下成员角色，默认情况下是安装<code>k8s-1.11</code>版本。然后点击<code>下一步</code>：<br><img src="/images/rancher6.png" alt="抱光妹"></p><p>下一步很重要了，先在第一台172.20.52.12上勾选所有的角色以及输入对应IP，然后会web页面下面生成一个命令，将这个命令在172.20.52.12上执行一下，瞬间它就会尝试去注册到rancher：<br><img src="/images/rancher1.png" alt="抱光妹"></p><p>如果注册不成功，web提示<code>[etcd]Pulling image [rancher/coreos-etcd:v3.12.18] on host XXX</code>的话，那么还要去该服务器上手动<code>docker pull rancher/coreos-etcd:v3.12.18</code>一下，不久之后就会看到主机被成功注册到rancher上：<br><img src="/images/rancher7.png" alt="抱光妹"></p><p>点击<code>主机</code>，能看到一点CPU和内存的细节：<br><img src="/images/rancher8.png" alt="抱光妹"></p><h2><span id="安装kuberctl">安装kuberctl</span></h2><p>使用rancher部署的k8s集群是没有自带kuberctl命令的，只能通过rancher页面的执行<code>kubectl命令行</code>来操作，若需要worker里使用kubectl，那就得手动安装，过程如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl<span class="comment">#国内可以正常打开，表怕</span></span><br><span class="line">chmod +x kubectl</span><br><span class="line">sudo mv ./kubectl /usr/local/bin/kubectl</span><br><span class="line">echo <span class="string">"source &lt;(kubectl completion bash)"</span> &gt;&gt; ~/.bash_profile  <span class="comment"># 增加自动补全功能  </span></span><br><span class="line">kubectl version</span><br></pre></td></tr></table></figure></p><p>此时得到的结果应该是：<br><img src="/images/rancher9.png" alt="抱光妹"></p><p>返回到rancher的集群页面，点击<code>kubeconfig文件</code>，将里面的内容复制到<code>~/.kube/config</code>里（没有就创建一个），保存退出之后，重开一个终端就能正常使用了，如图：<br><img src="/images/rancher10.png" alt="抱光妹"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.cnblogs.com/horizonli/p/10572834.html" target="_blank" rel="noopener">https://www.cnblogs.com/horizonli/p/10572834.html</a><br><a href="https://systemoutprint.github.io/kubernetes/2018/07/19/kubernetes%E9%9B%86%E7%BE%A4%E7%97%9B%E8%8B%A6%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">https://systemoutprint.github.io/kubernetes/2018/07/19/kubernetes%E9%9B%86%E7%BE%A4%E7%97%9B%E8%8B%A6%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</a></p>]]></content>
    
    <summary type="html">
    
      批量删除exited状态的容器是：docker rm $(sudo docker ps -qf status=exited)
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
      <category term="rancher" scheme="http://yoursite.com/tags/rancher/"/>
    
      <category term="云原生" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>在Docker里使用s6-svscan做进程守护</title>
    <link href="http://yoursite.com/2019/07/23/%E5%9C%A8Docker%E9%87%8C%E4%BD%BF%E7%94%A8runit%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2019/07/23/在Docker里使用runit监控服务状态/</id>
    <published>2019-07-23T02:29:22.000Z</published>
    <updated>2019-07-23T09:21:00.602Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="为什么要用s6">为什么要用s6</span></h2><p>容器的哲学就是“容器里最好只有一个模块”，也就是常说的<code>容器即进程（one process per container）</code>。但是现在这个哲学有所动摇，很多人认为<code>容器即服务（one thing per container）</code>，毕竟总有些特殊场景我们需要在一个docker里安装多个模块。容器虽然可以在<code>docker run</code>的时候可以指定<code>--restart=always</code>，但是这个并不能对pid不为1的进程起到看门狗的作用，如果pid不为1的进程crash了，那么就不会重启而出现故障了。于是需要一个真正的看门狗来重启这个服务。可用于docker的看门狗品种有很多，详情可见 <a href="https://www.iamle.com/archives/tag/runit" target="_blank" rel="noopener">https://www.iamle.com/archives/tag/runit</a> 这篇文章。我在那篇文章里选择了<code>s6</code>。虽然听说有赞在生产环境里已经用了<code>runit</code>，但是我搞了一天都没有搞明白<code>runit</code>怎么用，而且关于<code>runit</code>的资料都是2017年之前的，就放弃了…</p><p>首先先在<code>/opt/service</code>里准备两个服务，分别是<code>app1</code>和<code>app2</code>，在各自的文件家里分别创建run和finish两个文件，结构如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@func-lcshop-Harbor opt]<span class="comment"># tree service/</span></span><br><span class="line">service/</span><br><span class="line">├── app1</span><br><span class="line">│   ├── finish</span><br><span class="line">│   └── run</span><br><span class="line">└── app2</span><br><span class="line">    ├── finish</span><br><span class="line">    └── run</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> directories, <span class="number">4</span> files</span><br></pre></td></tr></table></figure></p><p>这个run文件就是进程的启动文件，<code>app1/run</code>内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@func-lcshop-Harbor app1]<span class="comment"># cat run </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">echo <span class="string">"Started APP1 service..."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.3</span>&#125;</span><br><span class="line">do</span><br><span class="line">    echo <span class="string">"这里是第一个程序！"</span></span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo <span class="string">"Oh no!我嗝屁了..."</span> &gt;&amp;<span class="number">2</span><span class="comment">#3秒就死掉</span></span><br><span class="line">exit <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>而<code>app2/run</code>的内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">echo <span class="string">"Started app2 service..."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;<span class="number">1.</span><span class="number">.3000</span>&#125;<span class="comment">#这里懒，就直接写了3000秒</span></span><br><span class="line">do</span><br><span class="line">    echo <span class="string">"这是第二个程序！"</span><span class="comment">#这里做了区分</span></span><br><span class="line">    date</span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo <span class="string">"Oh no!我嗝屁了..."</span> &gt;&amp;<span class="number">2</span></span><br><span class="line">exit <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>我上面主要是为了模拟程序挂掉的场景，实际run脚本应该是长时间运行的。</p><p>而finish的作用主要是执行程序退出后的操作，也就是run结束后的操作。<font color="red">这里要注意！因为s6会自动重启run脚本，如果在finish里也写了启动run脚本，那么就会有两个run脚本运行！</font></p><p><code>app1/finish</code>内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">echo <span class="string">"app1 挂掉啦！..."</span></span><br><span class="line">echo <span class="string">"app1 restart ok!"</span></span><br></pre></td></tr></table></figure></p><p>然后我们准备一个<code>dockerfile</code>，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ADD https://github.com/just-containers/s6-overlay/releases/download/v1<span class="number">.21</span><span class="number">.8</span><span class="number">.0</span>/s6-overlay-amd64.tar.gz /tmp/<span class="comment">#这个网站可能链接比较慢，所以推荐先下载然后COPY到容器里</span></span><br><span class="line">RUN tar xzf /tmp/s6-overlay-amd64.tar.gz -C /<span class="comment">#解压缩到根目录下</span></span><br><span class="line">CMD [<span class="string">"/bin/s6-svscan"</span>,<span class="string">"/opt/service"</span>]<span class="comment">#/opt/service就是app1和app2的路径</span></span><br></pre></td></tr></table></figure></p><p>执行<code>docker build -t=&quot;s6:0.1&quot; .</code>创建镜像，再使用<code>docker run -it --name s6demo -v /opt/service:/opt/service s6:0.1</code>启动这个s6demo的容器，在容器启动时就会发现s6会扫描<code>/opt/service</code>文件夹，执行对应的run脚本，当run脚本意外退出时，s6会自动重启，如图：<br><img src="/images/docker21.png" alt="抱光妹"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/just-containers/s6-overlay#the-docker-way" target="_blank" rel="noopener">https://github.com/just-containers/s6-overlay#the-docker-way</a><br><a href="https://sourcediver.org/blog/2014/11/17/using-runit-in-a-docker-container/" target="_blank" rel="noopener">https://sourcediver.org/blog/2014/11/17/using-runit-in-a-docker-container/</a><br><a href="https://segmentfault.com/a/1190000006644578" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006644578</a><br><a href="https://it.ismy.fun/2018/03/09/runit-example/" target="_blank" rel="noopener">https://it.ismy.fun/2018/03/09/runit-example/</a></p>]]></content>
    
    <summary type="html">
    
      有一些观念还是要慢慢转变的
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="s6-svscan" scheme="http://yoursite.com/tags/s6-svscan/"/>
    
  </entry>
  
  <entry>
    <title>python3监控https证书过期时间</title>
    <link href="http://yoursite.com/2019/07/17/python3%E7%9B%91%E6%8E%A7https%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2019/07/17/python3监控https证书过期时间/</id>
    <published>2019-07-17T11:43:40.000Z</published>
    <updated>2019-07-19T06:30:22.574Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>上周日，我们的一个https证书到期了，结果运维没有事前检查到，导致服务中断，于是赶紧亡羊补牢一个python3的脚本：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 作者：ChrisChan</span></span><br><span class="line"><span class="comment"># 用途：获取https证书的过期时间，需要先执行pip3 install pyopenssl</span></span><br><span class="line"><span class="keyword">from</span> urllib3.contrib <span class="keyword">import</span> pyopenssl <span class="keyword">as</span> reqs</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 公网验证</span></span><br><span class="line">cert = reqs.OpenSSL.crypto.load_certificate(reqs.OpenSSL.crypto.FILETYPE_PEM, reqs.ssl.get_server_certificate((<span class="string">'cn.imoulife.com'</span>, <span class="number">443</span>)))</span><br><span class="line"></span><br><span class="line">notafter = datetime.strptime(cert.get_notAfter().decode()[<span class="number">0</span>:<span class="number">-1</span>], <span class="string">'%Y%m%d%H%M%S'</span>)<span class="comment">#获取到的时间戳格式是ans.1的，需要转换</span></span><br><span class="line">remain_days = notafter - datetime.now()<span class="comment"># 用证书到期时间减去当前时间</span></span><br><span class="line">print(remain_days.days)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 离线验证</span></span><br><span class="line"><span class="keyword">from</span> OpenSSL <span class="keyword">import</span> crypto</span><br><span class="line"></span><br><span class="line">cert_file = <span class="string">'F:\\crt文件的路径\\mycert.crt'</span></span><br><span class="line">cert2 = crypto.load_certificate(crypto.FILETYPE_PEM, open(cert_file).read())</span><br><span class="line">cert2.get_version()</span><br><span class="line">subject = cert2.get_subject()</span><br><span class="line">subject.get_components()</span><br><span class="line">print(<span class="string">"域名是："</span>,subject.CN)</span><br><span class="line">print(<span class="string">"终止的时间戳是："</span>,cert2.get_notAfter())</span><br></pre></td></tr></table></figure></p><p>pyopenssl可以给与我们的https信息非常的丰富，除了到期时间之外，还有如下几个常用项：</p><ol><li>get_subject()：返回证书域名</li><li>get_version()：返回证书版本</li><li>get_issuer()：证书颁发机构</li></ol><p>更多信息可以去看 <a href="https://www.pyopenssl.org/en/stable/index.html" target="_blank" rel="noopener">https://www.pyopenssl.org/en/stable/index.html</a> 官网介绍。</p><p>进一步加工后的脚本是:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">from</span> urllib3.contrib <span class="keyword">import</span> pyopenssl <span class="keyword">as</span> reqs</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行参数</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'本脚本获取https证书到期时间'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-w'</span>, <span class="string">'--www'</span>, metavar=<span class="string">'https网站,如cn.imoulife.com'</span>, required=<span class="keyword">True</span>, dest=<span class="string">'sites'</span>,  nargs=<span class="string">'+'</span>, help=<span class="string">'请一定要输入监控的https网站'</span>)  <span class="comment"># required表示此字段一定需要,nargs=’+’ 表&gt;示至少一个参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 公网验证</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_notafter</span><span class="params">(www)</span>:</span></span><br><span class="line">    cert = reqs.OpenSSL.crypto.load_certificate(reqs.OpenSSL.crypto.FILETYPE_PEM, reqs.ssl.get_server_certificate((www, <span class="number">443</span>)))</span><br><span class="line"></span><br><span class="line">    notafter = datetime.strptime(cert.get_notAfter().decode()[<span class="number">0</span>:<span class="number">-1</span>], <span class="string">'%Y%m%d%H%M%S'</span>)</span><br><span class="line">    remain_days = notafter - datetime.now()         <span class="comment"># 用证书到期时间减去当前时间</span></span><br><span class="line">    print(www,<span class="string">"证书到期天数是："</span>,remain_days.days)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> site <span class="keyword">in</span> args.sites:</span><br><span class="line">        get_notafter(site)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"出现错误，请检查域名是否正确或者可达性！"</span>)</span><br></pre></td></tr></table></figure></p><p>执行效果如下：<br><img src="/images/pyredis3.png" alt="抱光妹"></p><h2><span id="shell脚本">shell脚本</span></h2><p><a href="http://noops.me/?p=945" target="_blank" rel="noopener">http://noops.me/?p=945</a> 这个小米的运维网站分享一个非常不错的shell脚本来监控证书，脚本如下：<br>    <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/sh</span><br><span class="line"> </span><br><span class="line">host=$1</span><br><span class="line">port=$2</span><br><span class="line">end_date=`openssl s_client -host $host -port $port -showcerts &lt;/dev/null 2&gt;/dev/null |</span><br><span class="line">          sed -n '/BEGIN CERTIFICATE/,/END CERT/p' |</span><br><span class="line">      openssl x509 -text 2&gt;/dev/null |</span><br><span class="line">      sed -n 's/ *Not After : *//p'`</span><br><span class="line"><span class="meta">#</span> openssl 检验和验证SSL证书。</span><br><span class="line"><span class="meta">#</span> &lt;/dev/null 定向标准输入，防止交互式程序Hang。从/dev/null 读时，直接读出0 。</span><br><span class="line"><span class="meta">#</span> sed -n 和p 一起使用，仅显示匹配到的部分。 //,// 区间匹配。</span><br><span class="line"><span class="meta">#</span> openssl x509 -text 解码证书信息，包含证书的有效期。</span><br><span class="line"> </span><br><span class="line">if [ -n "$end_date" ]</span><br><span class="line">then</span><br><span class="line">    end_date_seconds=`date '+%s' --date "$end_date"`</span><br><span class="line"><span class="meta">#</span> date指令format字符串时间。</span><br><span class="line">    now_seconds=`date '+%s'`</span><br><span class="line">    echo "($end_date_seconds-$now_seconds)/24/3600" | bc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>上面那个有两个小地方可以改进下：<code>echo “HOST: test.com /r/n GET / HTTP/1.1″|openssl s_client -connect test.com:443</code> 这样可以增加速度，因为<code>openssl s_client</code>只负责链接，后面是请求内容如果不输入的话就是等待超时，时间会很长。而且增加一个参数<code>-servername</code>可一直开启<code>TLS SNI support</code>，可以检测一个ip多个证书的情况。</p><h2><span id="其他监控证书的网站">其他监控证书的网站</span></h2><p>如果不想用脚本监控可以用第三方网站监控，下面这三个网站方法都一样：就是填入自己的邮箱注册账户，然后在页面输入自己要监控的域名，然后会给你一个剩余时间，如果快到期了就会给你发邮件通知，这三个网站分别是：</p><ol><li>letsmonitor.org          每小时检测一次，但是发送告警邮件只有一次</li><li>certificatemonitor.org   非常简单，只能443端口，一共会发9次邮件通知</li><li><a href="https://keychest.net/" target="_blank" rel="noopener">https://keychest.net/</a>    它支持api，邮件每周一次发送，比较好</li></ol><p>详情可见<a href="https://www.sooele.com/2784.html" target="_blank" rel="noopener">https://www.sooele.com/2784.html</a> 。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://flyhigher.top/develop/755.html" target="_blank" rel="noopener">https://flyhigher.top/develop/755.html</a><br><a href="https://blog.skk.moe/post/checkssl-status/" target="_blank" rel="noopener">https://blog.skk.moe/post/checkssl-status/</a><br><a href="https://blog.csdn.net/tzdjzs/article/details/28124609" target="_blank" rel="noopener">https://blog.csdn.net/tzdjzs/article/details/28124609</a><br><a href="https://www.conum.cn/program/python/241.html" target="_blank" rel="noopener">https://www.conum.cn/program/python/241.html</a> （pyopenssl的介绍）<br><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c13/p03_parsing_command_line_options.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c13/p03_parsing_command_line_options.html</a> (python命令行参数)</p>]]></content>
    
    <summary type="html">
    
      如果想要固定容器IP，可以先&quot;docker network create --subnet=IP段/16 网段名称&quot;，然后docker run的时候加上&quot;--net 网段名称 --ip 具体IP&quot;即可
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python3" scheme="http://yoursite.com/tags/python3/"/>
    
      <category term="https证书" scheme="http://yoursite.com/tags/https%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用centos7部署Harbor私有仓库</title>
    <link href="http://yoursite.com/2019/07/15/%E4%BD%BF%E7%94%A8Debian9%E9%83%A8%E7%BD%B2Harbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2019/07/15/使用Debian9部署Harbor私有仓库/</id>
    <published>2019-07-15T07:48:36.000Z</published>
    <updated>2019-07-24T08:21:44.972Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装过程">安装过程</span></h2><p>首先，我当你在centos7上已经装好了docker，如图：<br><img src="/images/harbor1.png" alt="抱光妹"></p><p>harbor官方更推荐使用docker-compose(1.18.0+)来配合安装，于是乎我们要安装一下docker-compose，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/<span class="number">1.24</span><span class="number">.1</span>/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="comment">#这一步国内的服务器可能会比较费时间</span></span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line">[root@func-lcshop-Harbor ~]<span class="comment"># docker-compose -v</span></span><br><span class="line">docker-compose version <span class="number">1.24</span><span class="number">.1</span>, build <span class="number">4667896</span>b</span><br></pre></td></tr></table></figure></p><p>然后下载离线的harbor1.8安装包：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/harbor-releases/release<span class="number">-1.8</span><span class="number">.0</span>/harbor-offline-installer-v1<span class="number">.8</span><span class="number">.2</span>-rc1.tgz</span><br><span class="line">tar -zxvf harbor-offline-installer-v1<span class="number">.8</span><span class="number">.2</span>-rc1.tgz</span><br></pre></td></tr></table></figure></p><p>进入harbor的文件夹去修改一下<code>harbor.yml</code>，将hostname改成服务器的外网地址，不过不想要默认的80端口，同时可以加上端口号，如下：<br><img src="/images/harbor2.png" alt="抱光妹"></p><p>文件下面还有一个<code>harbor_admin_password</code>，这个是登录页面的初始密码。<font color="red">注意！密码不可以有!和@，不然命令行会报错！而且这个密码只能是第一次登陆可用，如果要改</font>然后执行<code>./install.sh</code>，如下：<br><img src="/images/harbor3.png" alt="抱光妹"></p><p>安装完毕了之后，看一下机器里生成了很多docker容器：<br><img src="/images/harbor5.png" alt="抱光妹"></p><p>再去浏览器打开<code>ip:端口</code>就能看到harbor的页面，是不是超简单？<br><img src="/images/harbor4.png" alt="抱光妹"></p><p>如果想要更换端口，在修改完<code>harbor.yml</code>之后，执行如下才会生效：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down -v</span><br><span class="line">./prepare</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p><h2><span id="修改密码">修改密码？</span></h2><p>假设我们已经修改了密码，并且重启了docker-compose，此时用命令行的方式访问harbor镜像库（推荐使用<code>--password-stdin</code>方法而不是在命令行里直接输入密码，先创建一个<code>/root/.harborpwd</code>文件，里面写入<code>harbor.yml</code>的<code>harbor_admin_password</code>），使用<code>docker login -u admin --password-stdin harbor外网IP &lt; /root/.harborpwd</code>试试，竟然返回<code>unauthorized: authentication required</code>这个错误！为什么呢？因为上面说了<code>harbor_admin_password</code>里的密码只能第一次使用，之后改密码了是不能通过<code>harbor.yml</code>修改的。</p><p>那么应该如何修改密码？需要进到harbor的数据库里。现在新的harbor数据库默认是<code>postgresql</code>，所以那些重置mysql密码的文章可以直接略过了。</p><p>具体修改的方法如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@func-lcshop-Harbor ~]<span class="comment"># docker exec -it harbor-db /bin/bash#先登录到db容器里</span></span><br><span class="line">root [ / ]<span class="comment"># psql -h postgresql -d postgres -U postgres#这里需要输入配置文件里db密码，默认的是root123</span></span><br><span class="line">Password <span class="keyword">for</span> user postgres: </span><br><span class="line">psql (<span class="number">9.6</span><span class="number">.10</span>)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># \c registry</span></span><br><span class="line">You are now connected to database <span class="string">"registry"</span> <span class="keyword">as</span> user <span class="string">"postgres"</span>.</span><br><span class="line">registry=<span class="comment"># select * from harbor_user;</span></span><br><span class="line"> user_id |  username  |          email          |             password             |    realname    |    comment     | deleted | reset_uuid |               salt               | sysadmin_flag |       creation_time        |        update_time  </span><br><span class="line">---------+------------+-------------------------+----------------------------------+----------------+----------------+---------+------------+----------------------------------+---------------+----------------------------+----------------------------</span><br><span class="line">       <span class="number">2</span> | anonymous  | anonymous@example.com   |                                  | anonymous user | anonymous user | t       |            |                                  | f             | <span class="number">2019</span><span class="number">-07</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">32.288001</span> | <span class="number">2019</span><span class="number">-07</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">32.288001</span></span><br><span class="line">       <span class="number">1</span> | admin      | admin@example.com       | a71a7d0df981a61cbb53a97ed8d78f3e | system admin   | admin user     | f       |            | ah3fdh5b7yxepalg9z45bu8zb36sszmr | t             | <span class="number">2019</span><span class="number">-07</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">32.288001</span> | <span class="number">2019</span><span class="number">-07</span><span class="number">-24</span> <span class="number">04</span>:<span class="number">05</span>:<span class="number">31.260468</span></span><br><span class="line">(<span class="number">3</span> rows)</span><br></pre></td></tr></table></figure></p><p>harbor采用的加密方式叫<code>PBKDF2</code>，在国外挺流行的，在国内用的人还不多。如果对这个比较感兴趣的可以去看 <a href="http://phantom0301.cc/2017/02/08/harborpass/" target="_blank" rel="noopener">http://phantom0301.cc/2017/02/08/harborpass/</a> 这个文章，里面还有一个python2的脚本来帮助生成密码。</p><p>如果想改回默认的harbor12345，就在postgresql里执行<code>update harbor_user set password=&#39;a71a7d0df981a61cbb53a97ed8d78f3e&#39;, salt=&#39;ah3fdh5b7yxepalg9z45bu8zb36sszmr&#39; where username=&#39;admin&#39;;</code>即可，不过我更推荐换一个新的密码，同时 <code>update harbor_user set username=&#39;其他用户名&#39; where user_id=1;</code>，这样把admin也给改掉。</p><p>退出harbor-db容器，再新建<code>/etc/docker/daemon.json</code>，里面内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"insecure-registries"</span> : [<span class="string">"Harbor外网IP地址"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存退出并且重启docker之后，此时就可以在命令行尝试登陆harbor了，如图：<br><img src="/images/harbor6.png" alt="抱光妹"></p><p>图中的WARNING意思是密码会以一个比较简单的加密方式保存在/root/.docker/config.json里，如果你有好的习惯，每次都会logout的话，那么这个文件还是会自动删除掉这个密码的。</p><p>如果想要给harbor开启ldap，请看<a href="https://github.com/goharbor/harbor/blob/master/docs/configure_user_settings.md" target="_blank" rel="noopener">https://github.com/goharbor/harbor/blob/master/docs/configure_user_settings.md</a> 。</p><h2><span id="上传镜像">上传镜像</span></h2><p>整个镜像上传的过程如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker login -u admin --password-stdin harbor外网IP &lt; /root/.harborpwd#登录</span><br><span class="line">docker tag [ImageId] harbor外网IP/repository名/具体镜像名:版本号#打一个tag</span><br><span class="line">docker pull harbor外网IP/repository名/具体镜像名:版本#推送</span><br><span class="line">docker rmi harbor外网IP/repository名/具体镜像名:版本#这一步是删除tag</span><br></pre></td></tr></table></figure></p><p>repository名这个要在harbor上事前生成，不然无法push，会报错：<code>denied: requested access to the resource is denied</code>。上传上去的镜像会保存在<code>/data/registry/docker/registry/v2/repositories/</code>这个路径下，所以如果是有很多个镜像，建议<code>/data</code>盘买大一点。</p><h2><span id="配置https和高可用方案">配置https和高可用方案</span></h2><p>其实在<code>harbor.yml</code>下面就已经有配置https的地方，但是官方的建议是不要在Harbor上启用https，而是在将Harbor放置到一个SLB的后边，配置SLB的端口转发进行访问。或者是再装一个nginx，进行nginx的端口转发。具体配置这里就不写了。</p><p>如果想做一个HA方案的话，可以按照如下的方式构建一个（主从模式真的很不靠谱）：<br><img src="/images/harbor7.png" alt="抱光妹"></p><p>负载均衡同时还要承担健康检查的任务，而Redis用于数据的缓存和消息队列的实现，MySQL存储用户信息和仓库信息，云存储用来存储Docker镜像。</p><h2><span id="配置阿里云oss做后端存储">配置阿里云OSS做后端存储</span></h2><h2><span id="参考资料">参考资料</span></h2><p><a href="https://youendless.com/post/docker_login_pass/" target="_blank" rel="noopener">https://youendless.com/post/docker_login_pass/</a><br><a href="https://blog.51cto.com/lzlutao/2388635" target="_blank" rel="noopener">https://blog.51cto.com/lzlutao/2388635</a><br><a href="https://blog.frognew.com/2017/06/install-harbor.html" target="_blank" rel="noopener">https://blog.frognew.com/2017/06/install-harbor.html</a> （这个版本已经比较老了，只能参考）</p>]]></content>
    
    <summary type="html">
    
      使用notepad++去重的方法：设定替换里的目标是^(.*?)$\s+?^(?=.*^\1$)，然后勾选“正则表达式”和“匹配新行”，再全部替换即可。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="私有仓库" scheme="http://yoursite.com/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>這些年被Ainge拆毀的塞爾提克</title>
    <link href="http://yoursite.com/2019/07/11/%E9%80%99%E4%BA%9B%E5%B9%B4%E8%A2%ABAinge%E6%8B%86%E6%AF%80%E7%9A%84%E5%A1%9E%E7%88%BE%E6%8F%90%E5%85%8B/"/>
    <id>http://yoursite.com/2019/07/11/這些年被Ainge拆毀的塞爾提克/</id>
    <published>2019-07-11T13:28:58.000Z</published>
    <updated>2019-07-11T13:58:37.338Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><strong>原作者：老溫隨筆</strong></p><p>2019年選秀會上塞爾提克將替補中鋒Aron Baynes打包送往太陽隊，如果加上成為自由球員且可能一去不回頭的Kyrie Irving、Al Horford、Terry Rozier，以及成為自由球員但完全沒有續約消息的Daniel Theis，塞爾提克頓時成了沒有控衛、沒有中鋒，加上本來就沒有大前鋒的詭異陣容。這支一年前還誓言爭奪總冠軍的球隊，在幾天之內就變得連自家球迷都不認識的模樣。</p><p>自從2013年7月12日總管Danny Ainge正式將Kevin Garnett、Paul Pierce與Jason Terry打包送往籃網隊交換包含數個首輪選秀權的包裹後，短短六年裡塞爾提克在Ainge不斷的交易洗資產與總教練Brad Stevens的堅持不擺爛的兩極風格下意外地兩度打入東區冠軍賽，一年前甚至僅一場之差就足以重返總冠軍賽，讓塞爾提克成為聯盟裡最炙手可熱的球隊。</p><p>但是就在短短的一年裡，塞爾提克問鼎準後勇士時期王座的希望破滅。隨著球季中一波波的脫序演出，無論是場後Irving、Marcus Morris在媒體前的狂飆或是場上直接發洩不滿的舉動，連過去十幾年來幾乎沒有異音的波士頓媒體都逐漸脫離過往照著球隊餵養訊息過日子的生態，不斷的向這些球員發出怒火。當塞爾提克在東區第二輪以近乎毫無抵抗力的方式慘敗給公鹿隊，宛如1983年的悲劇重演的情節似乎也注定了這支完全不符內外期望的塞爾提克即將面對的悲慘未來。</p><h2><span id="歷史的借鏡">歷史的借鏡</span></h2><p>1983年球季結束後的第22天，原本以為自己地位依然穩固的總教練Bill Fitch意外得知一向力挺自己的老闆Harry Mangurian即將出售持股，三天後，在鬥爭中贏得勝利的總裁Red Auerbach正式重新掌握球隊，在眾叛親離下，Fitch只能黯然宣布下台。除了失去老闆Mangurian的力挺外，另一個壓垮Fitch的原因是成為自由球員的明星前鋒Kevin McHale表明不願意再替Fitch打球，而陣中除了Larry Bird以外的球員無論老少也都投下反對票。</p><p>故事的最後在老闆Mangurian用智力退試圖搶親的尼克隊讓McHale續留下獲得圓滿的結局。塞爾提克重新成為Auerbach的大家庭，孚眾望的助理教練K.C. Jones扶正成為總教練，McHale如願逼走了Fitch並重返球隊，Mangurian也成功地在八月將球隊賣給Dan Gaston。</p><p>重新站起的塞爾提克很快地在1984年東區冠軍賽裡以4：1淘汰了公鹿隊，報了一箭之仇，並在總冠軍賽裡擊敗了湖人隊拿下總冠軍。</p><p>也許，可以說當1983年Red Auerbach剷除球隊內部不安的因子Fitch後，這支球隊就獲得初步的止血，並在交易Dennis Johnson完成對湖人與公鹿部屬後重新回到正軌。</p><p>跟1983年相近的是2019年的塞爾提克也有一個最後近乎公認的麻煩人物Kyrie Irving，而球季結束後這個麻煩人物也近乎確定離隊。問題在於當你的麻煩人物是個總教練或是行政人員時，下手清除膿包並不會對球隊實力傷筋動骨，但當你的問題人物是個球員時，除非能夠以對等交易的方式進行，否則終將註定會折損球隊的實力。</p><p>而現在的塞爾提克問題更加複雜，因為Irving不僅是位球員，還是這支球隊最好的球員，也注定了這將會是一個難捱的暑假，即使，這個結果在兩年前其實就已經可以預知。</p><p>從Irving幾乎確定轉隊開始，對塞爾提克不利的消息就接踵而來。原本球團即使沒有Irving都想促成的Anthony Davis交易在經紀人Rich Paul出面喝止，湖人隊一口氣比照籃網隊加碼數個首輪選秀權下成了泡影。眼看著死敵日漸茁壯，當家中鋒Al Hoford宣布跳脫合約後因為換約談判觸礁而可能他去的消息傳出，不僅成了壓垮塞爾提克球迷希望的最後一根稻草，也意味著從2013年開始的重建畫下句點。</p><p>不要懷疑，無論是對波士頓這座體育城市，或是對塞爾提克而言，重建成功的標準只有一個：總冠軍。</p><p>有趣的是Horford離隊消息傳出後，塞爾提克向上交易第四順位、交易Bradley Beal或是Mike Conley等謠言開始大舉出籠，過去一年完全沒有動作的總裁Ainge也開始再度活躍。更在選秀會上送出了剛執行合約的Baynes，一瞬間，反手大力清除薪資的塞爾提克從原本沒有薪資空間變成了有開出頂薪的能力。</p><p>一年前還是眾人捧的塞爾提克在一年後不但牆倒眾人推，而且很有可能成為一支完全不同的球隊。</p><h2><span id="塞爾提克的東區冠軍賽魔咒">塞爾提克的東區冠軍賽魔咒</span></h2><p>如果檢視Danny Ainge的掌舵紀錄，會發現打入東區冠軍賽往往不是美好未來的起點，反而可能是旅程的終點。更可以發現當Ainge與背後的老闆們覺得球隊無法跨越高牆時做出的選擇幾乎都是整組拆掉重建，只是過去三次都是Ainge主動按下重建鈕，只有這一次是Ainge首度因為球員背離而被迫重建。<br><img src="/images/nba5.png" alt="抱光妹"></p><p>塞爾提克的未來尚在未定之天，過去一年的安定終究只是這十七年來的意外，但如果回顧過去三次的解體，除了第二回因為Garnett與Pierce逐漸衰老外，另外兩次主力都正當盛年，解體後的結果都讓球隊跌入更深的深淵，特別是剛打出生涯最佳成績的Isaiah Thomas與Jae Crowder被打包送往騎士交換Irving更是導致當前的大挫敗。</p><h2><span id="被拆毀的2002年塞爾提克">被拆毀的2002年塞爾提克</span></h2><p>只是當年Ainge接手後如何一手拆掉2002年打入東區冠軍賽的塞爾提克，已經沒有太多人記憶，如果經歷過那一段歷史，也許對現在塞爾提克的一片混亂就不會那麼意外，因為這曾經是身為塞爾提克球迷的日常。</p><p>當時塞爾提克的老闆傳承到Gaston家族的第二代Paul Gaston，跟熱愛籃球的老爸不同，Paul Gaston只是因為繼承了老爸的遺產而成為球隊的老闆，儘管球隊戰績跌落谷底，但因為NBA持續成長讓塞爾提克的價值也持續成長，於是覺得這是門好生意的Paul Gaston願意繼續經營下去。雖然Auerbach依然在球團裡擔任精神領袖的總裁一職保持門面，但Paul Gaston卻對剛退役的八零年代明星球員有諸多提防，例如一直被認為總有一天會回到波士頓承繼Auerbach衣缽的Larry Bird就始終被以顧問之名給晾在一旁，1993年就開始擔任助理教練的Dennis Johnson也始終無緣扶正。</p><p>當接掌國王的王子始終避免被有人望的王子所取代下，其他八零年代的球星如Ainge、McHale就更沒有插手機會，而先後轉戰太陽隊與灰狼隊。這層緊張關係終於在1997年塞爾提克手握兩張樂透籤，有高達19.9%的機率抽到Tim Duncan而爆開。</p><p>當規劃NBA史上第一個公然輸球拚選秀的總管M.L. Carr功成身退後，能夠指導Duncan的總管兼總教練空缺成了聯盟最搶手的工作，當時最熱門的人選除了老字號的名帥Larry Brown外，就屬Larry Bird的呼聲最高。</p><p>但最後，Paul Gaston宣布由畢業自麻州大，帶領Providence College打入NCAA四強賽，與波士頓有強烈地緣關係的Kentucky大學總教練Rick Pitino接手總教練，並明升暗降Auerbach到副董事長。雖然記者會上Pitino表示會考慮接手塞爾提克是在接到Bird的詢問電話之後，並表示希望Bird能夠考慮留在球團內協助，但此時的Bird也已經接到家鄉印第安那溜馬隊的總教練職缺探詢，只是基於禮貌不便在老東家宣布新任總教練時確定接任。</p><p>Pitino的塞爾提克總教練任期最後證明是場災難，但他帶來的首席助理教練Jim O’Brien擔任代理總教練時卻成功帶領以Antoine Walker與Paul Pierce為首的年輕球員在剩餘球季打出剛好五成勝率，第一個完整球季更寫下49勝33敗成績，不但重返季後賽並就此一路打到東區冠軍賽，距離上回Bird帶領球隊打入東冠已經間隔了十四年之久。</p><p>這個球季也是Walker成功洗白的一年。</p><p>Walker是M.L. Carr在1996年所選，隔年在大學恩師Pitino的全力支持下刷出了22.4分、10.2籃板與3.3助攻的成績，加上球隊從聯盟底部回升到36勝46敗，讓Walker成功入選了明星賽替補。只是少年得志加上教練團沒有強加約束，其實Pitino也約束不住已經在NBA混了一季，跟許多老將廝混養出一堆壞毛病的Walker。他囂張的態度惹惱了波士頓記者，不但給了他Employee #8的綽號，也成了媒體發洩不滿的稻草人，讓Walker在波士頓的名聲始終欠佳。</p><p>這局勢在O’Brien接手後開始轉變。Pitino在塞爾提克失敗最大的原因與Fitch相當接近，同為大學教練出身的兩人在球隊裡人緣極差，Pitino更刻意維持大學籃壇以總教練為首的金字塔結構，讓自己與球員之間的隔閡頗深，即使是大學子弟兵如Walker、Ron Mercer、Walter McCarty也難以直接與總教練接觸，所有的事情都靠居間扮演傳達與協調者的O’Brien傳遞，因此當O’Brien接手後很快地就讓球員團結一致的以季後賽為目標，雖然最後無緣，但O’Brien代理時帶隊打出24勝24敗已經是McHale退休後最佳的教練成績，也讓他獲得真除成為正式的塞爾提克總教練。</p><p>O’Brien除了改變總教練高高在上的姿態外，最重要的轉變是讓Walker、Pierce成為球隊決策的一環，無形中也讓球員與教練團間的隔閡消失。被賦予重任的Walker改變過去被媒體貼上的標籤，在暑假裡邀請隊友一起練球，到西岸跟Pierce練球，更把場上表現的機會讓給Pierce，自己扮演助攻的配角，這些都讓Walker的好感度快速累積。</p><p>最關鍵的還是Walker在2002年東區冠軍賽第三戰回到波士頓主場時展現的領導力。在前三節結束時塞爾提克大幅落後21分，鏡頭前只見到Walker在板凳上激動地對Pierce比手畫腳，第四節裡Pierce用單節獨得19分的表現幫助塞爾提克演出大逆轉，這也是塞爾提克脫離黑暗時期的象徵。</p><p>但沒人想到這也是塞爾提克的轉捩點。</p><p>將塞爾提克當作是一門生意的Paul Gaston在球隊重返季後賽價值快速上升後終於開啟了交易模式，並成功地在2002年9月將球隊易手給目前以Wyc Grousbeck家族為首的團隊。雖然新老闆沒有立刻撤換球團制服組，但懸而未決的總管人選卻在季後賽時傳出了可能人選，因此當2002-03季後賽塞爾提克在第二輪再次遭遇籃網隊時，所有媒體的焦點都落在可能接手籃球事務的Ainge身上。離開太陽隊教職後的Ainge轉任電視球評，他對於塞爾提克的過度依賴三分投射的打球方式多所評論，特別是對Walker的投籃選擇更是不假辭色，當傳出他可能接掌球隊時，預期他可能將全隊拆解的傳聞也開始在市場上流傳，讓原本就無力防守Jason Kidd的塞爾提克更加無助。球團最後確認人選消息傳出的時間剛好在第三戰前，在人心浮動下，整個第三戰完全失焦，塞爾提克也以76：94慘敗收場，最後慘遭橫掃。</p><p>只是諷刺的是Ainge在1988-89球季之所以被賣走，除了年輕最有交易價值外，他與新任總教練Jimmy Rogers交惡也是原因之一，而交惡的原因就是因為Ainge糟糕的三分投籃選擇。</p><h2><span id="obrien跨越時代的戰術思維">O’Brien跨越時代的戰術思維</span></h2><p><img src="/images/nba1.png" alt="抱光妹" title="2002-2003绿凯的三分出手点"><br>如果回顧當時的塞爾提克打法，O’Brien有許多跨越時代的想法。最知名的是2002-03球季塞爾提克以2155次三分球出手成為NBA史上第一支單季三分球出手次數突破2000次球隊，而且要到兩年後NBA才開始穩定有球隊單季出手突破2000次，可說是當前三分熱潮的真正開端。更重要的是O’Brien不僅僅是讓球員多投三分球，他也要求球隊減少在中距離的出手，同時大幅增加球隊在兩側底角的三分球出手次數。</p><p><img src="/images/nba2.png" alt="抱光妹" title="2002-2003国王的三分出手点"><br>對比另一個底角出手次數較多的國王隊，兩隊的投籃分布截然不同，這說明了O’Brien的塞爾提克在整個投籃的思維領先當代甚多，以致於無法讓當時的媒體所理解。</p><p>雖然塞爾提克本身角落三分球出手只占全隊三分球出手的23%在聯盟裡屬於後段，但總出手逼近500次，僅略低於剛好突破500次的馬刺隊（註），這數字比次高球隊多出超過30次。如果認為這數字只是單純因為O’Brien增加三分投射而來，那就大錯特錯，因為這是本季新任湖人隊總教練Frank Vogel在塞爾提克擔任數據影像分析師時所得出來的結論，讓O’Brien有了理論基礎，設計出這套以三分球取代命中率低的中距離，同時利用兩側底角距離較短的特性來增加威脅力的基本打法，而這正是現在NBA的主流思維。</p><p>最明顯的例子是小前鋒Eric Williams。1995年入隊的他常跟Walker一起在禁區內攪和，但被Pitino賣往金塊隊後卻因為受傷導致爆發力與敏捷性大幅衰退，重新被賣回塞爾提克後轉型成了防守大鎖，原本不出手三分球的他也開始嘗試在外圍接應。從2001-02球季開始Williams的角落三分球比重就在七成以上，2002-03球季的數據雖然稍降，但也有65.5%的出手比重是在兩側底角。同樣的情況也發生在Walter McCarty身上，2002-03球季有50.4%的出手在兩側底角，這個策略讓塞爾提克能夠利用雙槍的切入破壞力製造外圍空檔，也能夠讓進攻能力較弱的防守組球員在場上能利用較短三分距離有了牽制效果，讓對手不能肆意的內縮防線包夾雙槍。</p><p><img src="/images/nba3.png" alt="抱光妹" title="2002-2003马刺的三分出手点"><br>（註）馬刺隊的數字是因為Bruce Bowen有79.3%的三分球出手都在角落，一個人就出手超過一百八十次。</p><p>因此，帳面上看塞爾提克的天份在雙槍之後有明顯的落差，但這支球隊卻能夠很有效率的贏球。2002-03球季戰績之所以不進反退，一個極大的原因是Paul Gaston為了規避豪華稅且讓球隊賣相好看而刻意控制薪資，因此讓成為自由球員的Rodney Rogers以微幅增加的三年九百萬美金合約轉投死敵籃網隊。這筆薪水如果加上豪華稅將讓Gaston付出接近兩千萬美金，使得他堅持不肯放行。</p><p>Rodney Rogers的重要性在於他是塞爾提克攻守兩端所缺乏的關鍵人物。雖然資料上名列前鋒，但六呎七吋有235磅重的他能夠在防守時對抗對手的大前鋒甚至中鋒，進攻端更因為他每場出手3.5次命中率高達41.1%的三分球，讓對手不得不將長人拉至外圍防守Rogers，因此成了O’Brien調度上的活棋。</p><p>換言之，在2001-02球季O’Brien在交易大限換入Rogers後，O’Brien就已經當現今最熱門的衍生四號甚至外線中鋒的概念運用在Rogers身上，Walker、Pierce、Williams搭配Rogers，或是將Williams換成McCarty的四小前鋒是O’Brien即常使用的陣容，這也是當年O’Brien跨越時代的戰術思維。</p><p>換入Rogers後，塞爾提克的勝率從原本的56.3%攀升至66.7%，只差一勝就跨入五十勝俱樂部，少了Rogers讓O’Brien的攻守體系缺了一角，而在當年，這樣能夠投三分又能夠扛住對手中鋒的替代品幾乎沒有。</p><p>當Ainge確定接手，拆解陣容就成了時間早晚的問題。除了原本就對塞爾提克的打法與組隊方式非常有意見外，球隊薪資已經因為雙槍的兩張頂薪合約而捉襟見肘也是另一個因素。</p><p>交易1：<strong>送出Daris Songaila从国王得到Bandon Hunter和Orien Greene</strong></p><p>Ainge在五月九日第三戰時上任，很快的就在一個多月後的選秀會上大展身手。Ainge用2002年第50順位的Darius Songalia為籌碼向國王隊換來2003年與2005年的兩個二輪選秀。這筆交易據稱是Songalia的經紀人Mark Bartelstein拜託Ainge把自己客戶交易到有較多上場機會的球隊，只是當時的國王隊正當盛年，特別是前場的深度與高度俱佳，實在很難讓人信服Songalia能有更好的機會。</p><p>Songalia獲選後在夏季聯盟登場時展現了相當好的球賽解讀能力，以及非常靈巧的雙手，因此儘管體能遠遠不及NBA水準，接下來幾年一直都是堪用替補。</p><p>幾天後的選秀會上，Ainge用剛交易來的第二輪第56順位選了他選秀生涯最愛的類型：六呎七吋260磅重的矮胖型長人Brandon Hunter，但Hunter也跟大多數他選的矮胖型長人一樣沒有太多作用。而2005年的二輪成了第53順位，Ainge挑選了六呎四吋的得分後衛Orien Greene，只打了一年就被揮棄。</p><p>Ainge用生涯出賽495場平均6.9分、3.4籃板的堪用替補，換了兩個福袋。</p><p>交易2：<strong>送出Troy Bell和Dahntay Jones从灰熊得到Marcus Banks和Kendrick Perkins</strong></p><p>這筆交易只是Ainge瘋狂交易的開端，選秀會上他又用第16順位的Troy Bell與第20順位的Dahntay Jones跟前灰熊隊交換了第13順位的Marcus Banks與第27順位的Kendrick Perkins。這筆交易引起不少反彈，因為Bell是本地Boston College出品的後衛，是BC隊史上的得分王，不過只出賽六場就從聯盟中消失。Jones雖然沒有太突出表現，但至少在聯盟裡打滾了十三個球季，2015-16在騎士隊拿到了一枚戒指。</p><p>Banks是Ainge非常喜愛的控衛類型，六呎二吋高的小後衛，沒有外線可言，速度飛快，往後每幾年他就會在選秀會上挑上一個或交易來一個，近期的代表人物是Demetrius Jackson。</p><p>選秀後Banks參加了暑假在UMass Boston舉行的Shaw’s夏季聯盟。UMass Boston的校區在波士頓南邊，突出在大西洋中的小半島，校園裡的甘迺迪總統圖書館襯映著大西洋在炎夏下極美。當時UMass Boston的體育館是一般小型學校的規模，座椅是從兩側拉出來的活動式座椅，兩年的經驗累積下來習慣坐在第二或第三層的位置，這位置大致就是球員眼睛高度左右，可以清楚看到球員切入後眼光的移動，是判斷球員場上閱讀能力最好的角度。第一場只見場上的Banks速度飛快但運球不甚靈光，因此快速推進時得要聚精會神地盯住球瘋狂地往前快跑，也導致當他快速移動時的視角極窄，幾乎只有正前方的傳球視角，看完一場之後就知道這個第13順位打注定要打水漂。</p><p>Banks從來沒有成為Ainge口中的控球後衛，在2006年成為交易中的配菜，只在隊史留下5.3分、2.0助攻完全不及格的成績。</p><p>Perkins應該是交易裡知名度最高的球員，在今年的諸多紛擾裡是對Irving最不假辭色的退休球員，他是2014-15球季Irving在騎士隊的隊友。雖然是末代高中棄學生，Perkins是少數近乎沒有進攻技巧的高中棄學生，生涯前兩個球季幾乎沒有上場機會。身體十分鈍重，直到第三個球季才逐漸開竅，最後在Garnett入隊後成為禁區的防守核心。</p><p>也許，可以說Perkins救了這筆交易，但這筆交易最可悲的地方也在於Perkins救了這筆交易。</p><p>交易3：<strong>送出JR Bremer、Bruno Sundov和Ryan Gomes从骑士队得到了Jumaine Jones</strong></p><p>一個月後，Ainge又做出了另一筆交易，將六月底剛轉換為保證約的第二年控衛J.R. Bremer與六月底選擇執行球員選擇權的替補中鋒Bruno Sundov以及2005年第二輪打包送往騎士隊，用先簽後換的方式換回了小前鋒Jumaine Jones。Jones在騎士的兩個球季有9.0分、5.6籃板，被認為能升級塞爾提克在鋒線的深度，但在入隊後Jones卻沒有辦法獲得出場時間，只上場42場，留下2.2分、1.6籃板就在隔年被送往湖人隊。</p><p>Bremer是總管Chris Wallace在沙裡掏金的結果。出身St. Bonaventure University，大四有24.6分與3.1助攻，雖然在2002年選秀會上未受青睞，但在Shaw’s裡以大膽投射與防守贏得球隊青睞，成功入隊。開季後從替補打起，由於塞爾提克此時的控衛工作相對單純，運過半場後就交由雙槍處理，主要工作是擔任外圍接應的狙擊手，勇於出手的Bremer因此有許多發揮空間，更在一月取代老將Tony Delk成為球隊的先發控球，直到季末為了準備季後賽才再度由Delk先發。擔任先發的41場比賽裡Bremer有平均11.2分、3.5助攻的成績，同時有37.2%的三分球命中率。</p><p>Sundov是小牛隊1998年選秀會第二輪第35順位，七呎二吋的瘦長型克羅埃西亞中鋒。高中在麻州就讀，一直被認為是有潛力的攻擊型長人，但生涯前四年沒有太多表現機會，因此2002年暑假被Wallace以底薪簽下，但在26場比賽裡也只交出1.2分、1.1籃板的成績。</p><p>交易4：<strong>送出Antoine Walker和Tony Delk从小牛队得到Raef LaFrentz、Chris Mills、Jiri Welsch和Delonte West</strong></p><p>Ainge接掌球隊後所有媒體最關注的就是主將Walker的去留，接手一周Ainge就約談Walker討論未來合作。結束後Ainge對媒體說著：「我跟Walker談過，並告訴他我對他在這個暑假的期望，以及對新球季訓練營前的準備，這就是我們的計劃，繼續邁步向前。」</p><p>只是這個保證並沒有持續太久，10月20日，塞爾提克突然宣布將Walker、Delk打包送往小牛隊交換Pierce的大學隊友Raef LaFrentz，一對搖擺人Chris Mills與Jiri Welsch以及2004年的首輪選秀權。這筆交易幾乎毫無預警，因為前一天環球報隨隊記者Shira Springer還煞有其事地認真討論著塞爾提克開季的球員陣容，而Walker是她筆下的篤定人選。</p><p>交易一出，波士頓環球報的神級專欄作家傾巢而出。由最資深也是知名Walker厭惡者Bob Ryan寫體育版刊頭，包括現在還在執筆的Jackie MacMullan、長年隨隊記者Peter May與現役隨隊記者Springer都寫了文章討論。帳面上Ainge的理由是不久後即將成為自由球員的Walker在延長合約談判上堅不讓步，高達一千六百萬美金的頂薪年薪讓球團無力負擔，又擔心會在未來失去他而一無所有，於是做出了交易的抉擇。</p><p>看過這個，應該就不會意外Ainge如何處理Isaiah Thomas。</p><p>Delk是Walker的肯大隊友，也是聯盟有名的板凳好手，在前主控Kenny Anderson離隊後就是塞爾提克實際上的控球後衛。在塞爾提克兩季裡Delk練出了一手穩定的三分球，成為重要的外線射手，有39.5%的三分準度，同時一雙長臂也是球隊重要的後場防守者。</p><p>小牛隊提出的包裹裡，Mills曾經在1997年暑假與Pitino簽下合約，但球季還沒開打就被打包送往尼克隊交換包含McCarty在內的包裹。這次再度重返波士頓沒想到歷史又再度重演，因為受傷一直無法上場的Mills在隔年交易大限時又被放上交易桌上，數據上連一場替塞爾提克出賽的紀錄都未曾留下。Ainge利用Mills的六百六十萬美金合約做為幫助其他球隊平衡薪資的重要籌碼，終於在與老鷹、活塞的三方交易中扮演重要角色，讓活塞順利從老鷹處換得Rasheed Wallace，幫助活塞拿下2004年總冠軍。交易中塞爾提克另外送出控衛Mike James，換回另一個近似的控衛Chucky Atkins以及老將Lindsey Hunter與2004年首輪選秀權，James與Atkins這對戰力毫無幫助的互換也讓人開了眼界。</p><p>Welsch是相當有靈性的搖擺人，入隊後第一年有9.2分、3.7籃板與2.3助攻的成績，同時有38.1%的三分球命中率。不過2005年的交易大限Welsch又被打包送往騎士隊交換2007年的首輪選秀權。</p><p>這筆交易裡的主角LaFrentz是1998年選秀會的第三順位，但生涯卻一直為膝蓋傷勢所苦，始終沒能有所表現。小牛隊在2002年的交易大限換入了LaFrentz，並在球季結束後與他簽下一紙七年七千萬美金的肥約。儘管LaFrentz在小牛隊的一年多裡只有9.7分、5.5籃板的不及格成績，為了賣掉Walker的Ainge還是毅然決然地接手他剩下來六年長約，成了許多人批評的把柄。交易後LaFrentz依然因為膝傷所苦，表現並不穩定，最後終於在12月12日接受膝蓋手術而宣告球季提前結束，生涯在塞爾提克三季只有9.2分、5.8籃板。</p><p>面對媒體不斷的詢問Walker的私人恩怨說，Ainge只能不斷的否認，強調時間將會證明一切。不管是真心還是推託之詞，Ainge倒是不能說完全在說謊，因為2005年交易Welsch的同一天，他又將一年多前說毫無續約希望的Walker從老鷹隊給換了回來，目的是替塞爾提克爭取季後賽的機會。就這樣，Walker與LaFrentz一起在季後賽裡出戰，但塞爾提克打滿七場後敗在溜馬隊的手下。</p><p>球季結束後，Ainge又再一次將Walker打包以先簽後換的方式送往熱火隊，讓Walker成為第一個拿下冠軍的球員。</p><p>看到Walker這樣賣出去又買回來又賣出去，以及LaFrentz的數據，Ainge急於做出這筆交易是不是有個人恩怨也許見仁見智，但賠上了塞爾提克兩個球季這點卻是毫無爭議的事情。</p><p>交易5：<strong>送出Tony Battie、Kedrick Brown、Kedrick Brown从骑士队得到Ricky Davis、Chris Mihm、Michael Stewart和Ryan Gomes</strong></p><p>送走了Walker讓塞爾提克全隊士氣低迷，也讓全隊更加人心惶惶，誰也不知道自己的明天在哪裡。就在LaFrentz倒下的幾天後，Ainge又再一次做出交易，這次把中鋒Tony Battie、前鋒Williams與體能絕佳的搖擺人Kedrick Brown給送往騎士隊，交換中鋒Chris Mihm、Michael Stewart、搖擺人Ricky Davis與2005年的第二輪選秀權。</p><p>這一筆交易等於將塞爾提克上季除了Pierce、McCarty之外的主力正式全部出清，也把在球隊資歷最久的Williams再次推出球隊。</p><p>雖然是2000年的第七順位，但Chris Mihm始終只有替補中鋒的資質，球隊的先發中鋒依然是1997年第57順位由超音速所選，但在小聯盟裡浮沉三年，直到2000年才被塞爾提克看上帶入NBA的Mark Blount擔綱。</p><p>Michael Stewart綽號Yogi (Bear)，是六呎十吋的火鍋中鋒，但菜鳥球季在國王繳出4.6分、2.4阻攻之後就因為毫無節制的犯規而被各隊冷凍。在塞爾提克的一季裡只有平均0.3分、0.1阻攻的成績，0.8次的犯規換算成36分鐘將高達6.6次，一年後就從聯盟中消失。</p><p>這次交易中的主角Davis可說是Ainge早期交易史裡少數成功的球員，三個球季中留下16.2分、3.7籃板與3.4助攻，成為這幾個球季裡Pierce最主要的助拳者。2002-03球季Davis在幾乎無人的騎士隊裡成為第一主將，在有大量出手機會下繳出平均20.6分、4.9籃板與5.5助攻的全方位成績（Jones也是在這季打出成績）。只是在LeBron James入隊後，Davis就成了礙眼的存在，最後成了騎士隊出清的對象。Davis有得分能力也有外線準度，防守的態度也比在騎士隊時好上許多，但他始終不是一個能夠幫助球隊更上層樓的球員，各方面雜而不精，也因為功能與Pierce重疊性遠高於Walker，讓他的發揮空間受到壓縮。</p><p>2006年一月底Davis又跟Blount、Banks一起被打包送往灰狼隊，交換1998年狀元Michael Olowokandi、Wally Szczerbiak、Dwayne Jones與2009首輪選秀權。</p><p>1998年選秀會上的兩大長人Olowokandi與LaFrentz都在Ainge主政下來到了塞爾提克，但結果卻與選秀會上同樣悲慘。</p><p>塞爾提克送出的Williams是1995年首輪第14順位的新秀，跟1996年第六順位的Walker是一起度過黑暗歲月的夥伴，也是Walker在球隊裡最好的朋友。年輕時是宛如豺狼般的蠻幹型小前鋒，受傷後失去爆發力導致進攻能力大幅衰退，但原本不在意防守的他卻專注在防守上，負責防守對手最難纏的搖擺人，讓雙槍能夠減輕防守負擔，是個工作態度與團隊精神俱佳的自家球員。</p><p>經過這幾年，也該知道Ainge最不在乎的就是這些非關天賦的正面特質。</p><p>Williams是Walker最好的朋友，而Battie則是Pierce最好的朋友。當Pierce在2001年開季前於Buzz Club遇刺時，緊急抱著Pierce穿過Stuart Street到對街的新英格蘭醫療中心求助，保住Pierce一命的隊友正是Battie。</p><p>Buzz Club的位置在中國城與劇院區之間，雖然出事後沒多久Buzz Club就已經歇業，但原址一直都在經營夜店或是酒吧，並不是外界想像的是非之地。十多年前習慣將車停在Buzz Club旁大空地開設的停車場，每天那裏就不斷的玩著大型移車遊戲，現在停車場已經杳無蹤跡成了高樓大廈，但夜店依舊在。</p><p>Battie是1997年第五順位，1998-99球季開始前被賣到塞爾提克交換被Pitino打入冷宮的中鋒Travis Knight。Battie有六呎十一吋高230磅重，瘦長的體型讓他的防守能力一直被外界所忽略，但他在塞爾提克的生涯裡有平均1.1次的阻攻，是塞爾提克賴以為生的防守核心。O’Brien接手後特別替Battie設計一套在前防守的系統，利用他的一雙長手臂來騷擾對手後衛將球送往禁區的路徑。如果對手將球轉移到側翼，Battie可以利用自身敏捷性繼續保持在前防守，或是立刻轉換成傳統的防守位置。這一套防守有效的箝制對手將球送到中鋒的機會，再搭配Walker在後方的包夾，就曾經成功地限制住湖人隊當家中鋒Shaq O’Neal在禁區的威脅力。</p><p>跟受傷後的Williams或是沒有驚人天賦的Battie不同，2001年第11順位的Kedrick Brown則有讓人過目不忘的驚人天賦，那兩年在Shaw’s裡Brown幾乎快超過籃框的實戰扣籃動作至今依然震撼。但Brown始終沒有辦法把自己的天賦幻化成實際數據，二年制學院出身而成為樂透新秀的他缺少如Pierce一般苦練而來的下球技巧，這讓他無法利用切入來發揮自己的體能天賦，也沒有發展出足夠穩定的三分投射能力，加上個性缺少在NBA成功所必需的強大企圖心，讓他一直都沒能達到天賦體能所該有的表現，這也讓他在離隊後不久就從NBA消失。</p><p>Ainge主政下最糟糕的一點是2003年暑假剛開始，塞爾提克就製作了Tony Delk、Tony Battie的非正式版球衣，然後某些通路還買得到Kendrick Brown的球衣，買了之後，這些球員就通通被賣掉，於是通路賣不掉的球衣就瘋狂大拍賣。</p><p>連這都要坑殺球迷。</p><h2><span id="交易後的塞爾提克真的有不平庸">交易後的塞爾提克真的有不平庸？</span></h2><p>Ainger接手後改變了這個球隊的諸多面向，這一季塞爾提克的三分球出手數陡降至1599次，總教練O’Brien在季中終於難以忍受而宣布辭職，塞爾提克在代理總教練John Carroll努力團結球員下勉強以東區第八打入季後賽，但被Larry Bird擔任總管，Rick Carlisle擔任總教練的溜馬隊輕鬆橫掃出局。</p><p>那幾年的塞爾提克除了大量的三分球外，最著名的就是瘋狂不要命的防守態度，Williams、Battie、McCarty、Delk等防守組球員正是執行這套防守的核心人物，也是塞爾提克能夠逆勢獲勝的關鍵。</p><p>經過這幾年，也該知道Ainge對這些與天賦無關的事情一點也不在乎。</p><p>從五月九日上任到十二月十五日，Ainge花了七個多月的時間就送走了上一季名單中的七名球員，讓這隻曾經打入2002年東區冠軍賽的塞爾提克完全崩解，留在名單中的Vin Baker因為酗酒問題而在2004年二月被球隊解約，Tommy Heinsohn的愛將McCarty則在2005年交易大限前被送往太陽隊交換2007年的第二輪選秀權，被好友形容是被遺忘在孤島上的Pierce則熬過了地獄般的重建歲月拿下2008年總冠軍，但也在2013年被賣往籃網隊。</p><p>這七個月的跳樓大拍賣裡包含選秀會共有五筆交易，Ainge送出了十位球員與一枚二輪選秀權，收進了十一位球員、兩枚首輪與三枚二輪選秀權，已經展露出他喜歡收集選秀權的習性。在Ainge送出的十位球員裡有入選明星賽的Walker與球隊主力Delk、Williams、Battie以及年輕的Bremer，換進來的球員除了Davis外只有Welsch勉強對球隊有些助益。</p><p>這五筆交易後，Ainge在接下來到2007年選秀會交易Ray Allen前又發動了十二筆交易，不斷的將手上的球員洗成另一批球員，雖然因此累積了許多爛合約作為交易的資產，也累積了許多選秀權幻化為新秀，也讓這些年輕球員累積了許多壞習慣，導致塞爾提克的戰績不斷下滑，2006-07球季僅有24勝58敗，讓好不容易走出九零年代中黑暗時期的球迷又墜入無底深淵之中，也讓Pierce終於決定向球隊發出最後通牒，也才在2007年暑假有GAP的誕生。</p><p>這七個月的時間裡，展現了Ainge的許多特質，例如不計代價地送走自家球員，這在2013年拍賣GAP之後也有相同的舉動，只是這次Ainge很幸運地在大拍賣中分別與2014與2015年換到了Jae Crowder與Isaiah Thomas，並用他們帶領著一批浪人打入季後賽，再吸引Al Horford加盟終於再次打入東區冠軍賽。</p><p>但就像2002年的塞爾提克，奮戰不懈的態度與打死不退的防守在Ainge與老闆群的眼裡完全無法與天賦相提並論，最後終於參與許多人口中「就算再一百次也會選擇交易」的捨Thomas、Crowder就Irving的交易。</p><p>另一個不同處是Ainge對於自己挑選的球員有相當偏好，因此2003年的重建中毫無顧忌地拍賣除了Pierce之外的球員，而2017年則送走了自己在交易中挖掘的Thomas與Crowder，而留下自己挑選的Jaylen Brown、Jayson Tatum等年輕球員。</p><p>2003與2017的塞爾提克如果沒有拆散是否能拿下總冠軍？這問題誰也沒有答案，只能說如果留下核心繼續努力，也許有一拚的機會。當時絕大多數人都覺得這兩支球隊完全沒有機會，但這些人中又有一部分覺得有了Irving之後就有機會至少打入總冠軍賽。歷史打了這些人兩次巴掌，第一次是Irving、Gordon Hayward受傷後反而再次打入東區冠軍賽直到第七戰才落敗。第二次則是有了健康的Irving反而讓球隊分崩離析，不但離總冠軍更為遙遠，還成為眾人的笑柄。</p><p>也許關鍵就在對核心的認知，2017年與2018年兩度打入東區冠軍的原因不是因為Tatum或是Brown或是Horford，而是Thomas與Crowder入隊後帶給這支球隊的態度，打死不退的防守與永遠不放棄的精神，讓所有球員緊緊的團結在一起。而Ainge與背後的老闆們則認為關鍵因素在自己的眼光挑選了Tatum、Brown等人，因此一貫認為更高的天分與更多的明星就能打造出真正的冠軍球隊，而放任Irving恣意而為，最後摧毀了球隊。</p><p>兩年過去了，牆倒眾人推，Irving已經成了媒體棄兒，大多數人都已經忘了自己當時對這筆交易的喜悅以及本能覺得身高、天賦就是一切的迷思，當然，更沒有多少人記得十七年前那一連串交易所造成的夢靨。</p><h2><span id="ainge與auerbach的差異">Ainge與Auerbach的差異</span></h2><p><img src="/images/nba4.png" alt="抱光妹"><br>Hoop雜誌最後的2019年六月號裡，紀念John Havlicek的文章最後引用了Hondo自傳裡對1976年冠軍隊的描述，這不僅說明了為何Auerbach執政時期的塞爾提克即使又老又傷還是能夠笑傲江湖，也說明了為何有數位頂薪球員又有滿滿天賦的2019塞爾提克最後會落得樹倒猢猻散的下場。</p><p>「塞爾提克又再次拿下冠軍，我很確信聯盟裡很多球員不懂為何我們能屢屢奪冠，1975-76球季的塞爾提克是隊史上最脆弱的一隊，也是那四年裡最不強勢的一隊，卻拿下最後勝利。我們的紙上陣容不是聯盟最佳，而是由一群角色球員所組成的球隊，然而，在季後賽裡我們每個人都非常有效的扮演自己的角色。」</p><p>謹以此文，替這些年劃下一個句點。</p>]]></content>
    
    <summary type="html">
    
      好久没看到这样的一篇好文章了
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="nba" scheme="http://yoursite.com/tags/nba/"/>
    
  </entry>
  
  <entry>
    <title>Root用户删除文件爆Permission denied</title>
    <link href="http://yoursite.com/2019/07/11/Root%E7%94%A8%E6%88%B7%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E7%88%86Permission-denied/"/>
    <id>http://yoursite.com/2019/07/11/Root用户删除文件爆Permission-denied/</id>
    <published>2019-07-11T12:31:18.000Z</published>
    <updated>2019-07-11T12:55:53.157Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在一台服务器上使用<code>useradd</code>创建用户，竟然爆<code>Permission denied</code>，我靠，我明明是root，竟然没有权限增加新用户，如图：<br><img src="/images/lsattr5.png" alt="抱光妹"></p><p>此时注意到下面还有一句话：<code>useradd: cannot lock /etc/passwd; try again later</code>。于是怀疑到可能在/etc/下有一个文件把passwd锁住了。搜索一番，发现了<code>.pwd.lock</code>这个文件，但是发现这个文件不能删除和改名，如图：<br><img src="/images/lsattr1.png" alt="抱光妹"><br><img src="/images/lsattr2.png" alt="抱光妹"></p><p>此时的我觉得root身份受到了很大的冒犯，怎么还有这种鬼现象？突然想到，可能这个锁文件被人给<code>chattr</code>修改了，于是使用<code>lsattr</code>查看这个文件，发现就剩下一个e属性了：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ip<span class="number">-172</span><span class="number">-31</span><span class="number">-7</span><span class="number">-167</span> etc]<span class="comment"># lsattr .pwd.lock </span></span><br><span class="line">-------------e- .pwd.lock</span><br></pre></td></tr></table></figure></p><p>e属性是不能用<code>chattr -e</code>删除的，而且也是一个很普通的属性，那么问题出在哪呢？</p><p>在<code>/etc/</code>下执行<code>lsattr -R -a</code>递归的查看所有文件（包含隐藏文件），发现原来当初是把整个<code>/etc/</code>文件夹加了i，如图：<br><img src="/images/lsattr3.png" alt="抱光妹"></p><p>于是就在<code>/etc/</code>路径下使用<code>chattr -i .</code>破掉了i属性，此时再次尝试删除lock锁文件，终于删除掉，并且成功创建了用户，如图：<br><img src="/images/lsattr4.png" alt="抱光妹"></p>]]></content>
    
    <summary type="html">
    
      使用chattr +i保护重要文件还是很有必要的
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="lsattr" scheme="http://yoursite.com/tags/lsattr/"/>
    
  </entry>
  
  <entry>
    <title>使用pycurl来模拟curl效果</title>
    <link href="http://yoursite.com/2019/07/11/%E4%BD%BF%E7%94%A8pycurl%E6%9D%A5%E6%A8%A1%E6%8B%9Fcurl%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2019/07/11/使用pycurl来模拟curl效果/</id>
    <published>2019-07-11T01:58:12.000Z</published>
    <updated>2019-07-11T12:58:15.376Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装">安装</span></h2><p>centos下安装pycurl，如果直接使用<code>pip install pycurl</code>的话，可能会有<code>ERROR: Command &quot;python setup.py egg_info&quot; failed with error code 1 in /tmp/pip-install-hb0k0rkr/pycurl/</code>的错误，那么需要先安装一下<code>yum install python-devel curl-devel</code>就解决问题了。</p><p>如果是windows下安装pycurl就比较麻烦一点，需要先<code>pip install wheel</code>安装wheel，然后去<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a> 下载对应python版本的编译包到本地，然后在cmd命令行里<code>pip install 对应的.whl</code>就好了。但是注意<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a> 是需要翻墙登录的。</p><h2><span id="python3脚本">python3脚本</span></h2><p>pycurl的常用的常量列表可以看一下<a href="https://izsk.me/2017/12/27/%E4%BD%BF%E7%94%A8python%E5%BA%93pycurl%E6%9D%A5%E6%A3%80%E6%B5%8Bweb%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/" target="_blank" rel="noopener">https://izsk.me/2017/12/27/%E4%BD%BF%E7%94%A8python%E5%BA%93pycurl%E6%9D%A5%E6%A3%80%E6%B5%8Bweb%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/</a> 这个文章，我这里就直接写一下我的脚本：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pycurl</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">c = pycurl.Curl()</span><br><span class="line">url = <span class="string">'http://X.X.X.X:对应端口号'</span></span><br><span class="line">c.setopt(c.URL, url)</span><br><span class="line">c.setopt(c.HEADER, <span class="keyword">True</span>)</span><br><span class="line">c.setopt(pycurl.CONNECTTIMEOUT, <span class="number">5</span>)    <span class="comment"># 连接的等待时间，设置为0则不等待</span></span><br><span class="line">c.setopt(pycurl.TIMEOUT, <span class="number">5</span>)           <span class="comment"># 请求超时时间</span></span><br><span class="line">c.getinfo(pycurl.HTTP_CODE)             <span class="comment"># 返回的HTTP状态码</span></span><br><span class="line"><span class="comment">#c.setopt(c.POST,1)     #是否是post，默认是get</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    c.perform()     <span class="comment">#提交请求</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"连接异常！"</span> + str(e))</span><br><span class="line">    c.close()</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">HTTP_CODE = c.getinfo(c.HTTP_CODE)                  <span class="comment">#获取 HTTP 状态码</span></span><br><span class="line">print(<span class="string">'HTTP状态码: %s'</span> %(HTTP_CODE))</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure></p><p>不过pycurl有两个缺点，第一,整个请求头都会输出；第二,无法摘取到http协议版本号。</p><h2><span id="go脚本">GO脚本</span></h2><p>如果是想用go语言来实现curl效果，脚本如下：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/mikemintang/go-curl"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">url := <span class="string">"http://目标路径:目标端口"</span></span><br><span class="line"></span><br><span class="line">headers := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"User-Agent"</span>:    <span class="string">"Sublime"</span>,</span><br><span class="line"><span class="string">"Authorization"</span>: <span class="string">"Bearer access_token"</span>,</span><br><span class="line"><span class="string">"Content-Type"</span>:  <span class="string">"application/json"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cookies := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"userId"</span>:    <span class="string">"12"</span>,</span><br><span class="line"><span class="string">"loginTime"</span>: <span class="string">"15045682199"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queries := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"page"</span>: <span class="string">"2"</span>,</span><br><span class="line"><span class="string">"act"</span>:  <span class="string">"update"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postData := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"name"</span>:      <span class="string">"mike"</span>,</span><br><span class="line"><span class="string">"age"</span>:       <span class="number">24</span>,</span><br><span class="line"><span class="string">"interests"</span>: []<span class="keyword">string</span>&#123;<span class="string">"basketball"</span>, <span class="string">"reading"</span>, <span class="string">"coding"</span>&#125;,</span><br><span class="line"><span class="string">"isAdmin"</span>:   <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式操作</span></span><br><span class="line">req := curl.NewRequest()</span><br><span class="line">resp, err := req.</span><br><span class="line">SetUrl(url).</span><br><span class="line">SetHeaders(headers).</span><br><span class="line">SetCookies(cookies).</span><br><span class="line">SetQueries(queries).</span><br><span class="line">SetPostData(postData).</span><br><span class="line">Post()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> resp.IsOk() &#123;</span><br><span class="line">fmt.Println(resp.Body)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(resp.Raw)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述脚本执行效果：<br><img src="/images/go8.png" alt="抱光妹"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://pycurl.io/docs/latest/index.html" target="_blank" rel="noopener">http://pycurl.io/docs/latest/index.html</a> (官方文档)<br><a href="https://www.twilio.com/blog/2016/12/http-requests-in-python-3.html" target="_blank" rel="noopener">https://www.twilio.com/blog/2016/12/http-requests-in-python-3.html</a><br><a href="https://stackoverflow.com/questions/472179/how-to-read-the-header-with-pycurl" target="_blank" rel="noopener">https://stackoverflow.com/questions/472179/how-to-read-the-header-with-pycurl</a></p>]]></content>
    
    <summary type="html">
    
      想限制容器里的日志的大小和数量，可以在docker run的时候指定--log-opt max-size=1G --log-opt max-file=3，这样每个日志大小不超过1G，最多保存3个
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="curl" scheme="http://yoursite.com/tags/curl/"/>
    
      <category term="端口探测" scheme="http://yoursite.com/tags/%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Nginx使用proxy_pass里的坑</title>
    <link href="http://yoursite.com/2019/07/08/Nginx%E4%BD%BF%E7%94%A8proxy-pass%E9%87%8C%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2019/07/08/Nginx使用proxy-pass里的坑/</id>
    <published>2019-07-08T07:47:57.000Z</published>
    <updated>2019-07-10T03:46:12.932Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="第一坑">第一坑</span></h2><p>我们有一个后台服务A，架构是这样：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">管理员 ====&gt; nginx ====&gt; AWS的云服务器（服务A）</span><br></pre></td></tr></table></figure></p><p>此时在nginx上做了一个<code>proxy_pass</code>的转发，如下：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">8081</span>;</span><br><span class="line">    server_name xxx.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass aws云服务器的IP地址:对应端口;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一直用的挺好，但是后来这个服务业务量上来了，就扩了一台机器，也部署了A服务，然后在前面加上了一个ELB做最小连接数分配，如图：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AWS的云服务器<span class="number">1</span>（服务A）</span><br><span class="line">管理员 ====&gt; nginx ===&gt; ELB  ===&gt;</span><br><span class="line">AWS的云服务器<span class="number">2</span>（服务A）</span><br></pre></td></tr></table></figure></p><p>此时修改了一下<code>proxy_pass</code>的配置：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">8081</span>;</span><br><span class="line">    server_name xxx.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//aws的ELB域名地址:对应端口;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当时是好使的，但是第二天就不好使了，nginx调用结果是502 Bad Gateway，当时是分别curl路径然后又抓包，一路十三招查下来也没什么头绪。后来发现原来<code>proxy_pass</code>后面如果接的是域名地址的话，那么Nginx会在每次启动和重载设置时，使用DNS将域名解析为IP地址缓存下来，并在之后<font color="red">一直使用这个IP！</font>只有通过<code>nginx -s reload</code>这样的重启才会强制刷新IP，所以当时在nginx上抓包发现跳转的IP其实并不存在。由于在AWS中ELB的内网域名对应的IP并不是一直不变的，这才导致了上面的问题。</p><p>新更改的配置如下：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name xxx.xxx.net;</span><br><span class="line"></span><br><span class="line">    resolver DNS服务器地址 valid=<span class="number">30s</span>;#resolver 是 DNS 服务器地址, valid 设定 DNS 刷新频率</span><br><span class="line">    set $service_lb aws的ELB域名地址;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//$service_lb;#若有路径的必要，就加上$request_uri</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要特别注意的一点是set语句不能写到 location 里面，否则不会生效。</p><h2><span id="第二坑">第二坑</span></h2><p><code>proxy_pass</code>这个配置对相对路径和绝对路径也有很有讲究，比如：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//10.0.0.1:8080/;#这里以/结尾 </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>当访问 <a href="http://127.0.0.1/proxy/a/b/c.txt" target="_blank" rel="noopener">http://127.0.0.1/proxy/a/b/c.txt</a> 时，nginx匹配到<code>/proxy/</code>路径，把请求转发给10.0.0.1:8080服务，实际请求代理服务器的路径为<br><code>http://10.0.0.1:8080/a/b/c.txt</code>（不带location目录）。</p><p>如果是这么写的：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">         proxy_pass http:<span class="comment">//10.0.0.1:8080;#这里没有以/结尾</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>当访问 <a href="http://127.0.0.1/proxy/a/b/c.txt" target="_blank" rel="noopener">http://127.0.0.1/proxy/a/b/c.txt</a> 时，nginx匹配到<code>/proxy/</code>路径，把请求转发给10.0.0.1:8080服务，实际请求代理服务器的路径为<br><code>http://10.0.0.1:8080/proxy/a/b/c.txt</code>（带location目录），此时nginx会把匹配的proxy也代理给代理服务器。</p><p><code>proxy_pass</code>后面接多一级路径的情况跟上面一致。</p><h2><span id="补充一个host-400错误的故障">补充一个$host 400错误的故障</span></h2><p>400这个状态码是<code>Bad Request</code>，基本上就是请求header或者是<code>cookie</code>有问题，而请求header的问题要么是头过大要么是头没有。在<code>HTTP/1.0</code>里不支持Host请求头的，而在<code>HTTP/1.1</code>中，Host请求头部必须存在,否则会返回<code>400 Bad Request</code>。如果请求的URI不包含所请求服务的主机名，则必须为Host头字段指定一个空值。</p><p>nginx如果配置了<code>$http_host</code>变量做反向代理时，后端真实的服务器是需要知道请求的host头，而<code>$http_host</code>的值是’’，所以会触发400这个错误。这个情况就需要用<code>$hosts</code>来替代<code>$http_host</code>。</p><p>也就是说：<code>proxy_set_header Host $host</code>这一行的作用是把原http请求的Header中的Host字段也放到转发的请求里。如果不加这一行的话，nginx转发的请求header里就不会有Host字段，而服务器是靠这个Host值来区分你请求的是哪个域名的资源的。</p><p>还有一种400的情况：如果是GET请求没问题，而POST请求返回400错误，那么可能是websocket配置成了全局单独配置websocket的地址即可。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.jibing57.com/2018/11/27/nginx-with-dynamic-upstreams-to-ELB/" target="_blank" rel="noopener">https://www.jibing57.com/2018/11/27/nginx-with-dynamic-upstreams-to-ELB/</a><br><a href="http://www.syyong.com/net/Using-nginx-s-proxy_pass-function-to-do-domain-name-forwarding-causes-an-accident.html" target="_blank" rel="noopener">http://www.syyong.com/net/Using-nginx-s-proxy_pass-function-to-do-domain-name-forwarding-causes-an-accident.html</a><br><a href="https://blog.nswebfrog.com/2018/09/09/nginx-proxypass-dns/" target="_blank" rel="noopener">https://blog.nswebfrog.com/2018/09/09/nginx-proxypass-dns/</a><br><a href="https://www.jianshu.com/p/b113bd14f584" target="_blank" rel="noopener">https://www.jianshu.com/p/b113bd14f584</a><br><a href="https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html" target="_blank" rel="noopener">https://www.cnblogs.com/woshimrf/p/nginx-proxy-rewrite-url.html</a></p>]]></content>
    
    <summary type="html">
    
      如果要用go语言去在windows里写文件，那么换行符是\r\n而不是\n
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="proxy_pass" scheme="http://yoursite.com/tags/proxy-pass/"/>
    
  </entry>
  
  <entry>
    <title>Intellij Idea配置GO调用本地包</title>
    <link href="http://yoursite.com/2019/07/05/Intellij-Idea%E9%85%8D%E7%BD%AEGO%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%8C%85/"/>
    <id>http://yoursite.com/2019/07/05/Intellij-Idea配置GO调用本地包/</id>
    <published>2019-07-05T07:56:16.000Z</published>
    <updated>2019-07-08T13:04:43.330Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>go代码里使用import去导入包文件，比如常见的<code>import fmt</code>，这个命令实际上导入的就是<code>GOROOT\src\fmt</code>。但是当遇到需要导入本地包的时候，就需要配置一下。</p><p>我windows里的go脚本文件夹是<code>E:\github\GoeveryDay</code>，现在在这个文件夹里创建<code>src\chentest\</code>，然后在<code>src\</code>下面创建一个<code>chenchen.go</code>，在<code>chentest\</code>下创建<code>testtest.go</code>，如图：<br><img src="/images/go4.png" alt="抱光妹"></p><p>而<code>chenchen.go</code>的内容如下：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"chentest"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">chentest.XXX()</span><br><span class="line"><span class="keyword">var</span> s1 chentest.Player</span><br><span class="line">s1.Name = <span class="string">"iverson"</span></span><br><span class="line">s1.Number = <span class="number">3</span></span><br><span class="line">s1.Team = <span class="string">"76ers"</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在需要让<code>chenchen.go</code>能成功调用到<code>chentest.go</code>里的<code>XXX</code>函数，如果此时在<code>chenchen.go</code>里直接<code>import testtest.go所在文件夹</code>是会报错的，错误提示是<code>Cannot resolve file ‘testtest.go所在文件夹’</code>，这是因为程序在运行时先去GOROOT去搜索导入包，然后去GOPATH寻找导入包，最后在当前项目模块下寻找导入包，如果三个都找不到就会报错。</p><p>可见在idea中默认不支持直接导入本地Golang包，那么解决该问题的关键是明白GOROOT和GOPATH的作用，根据官方文档的解释GOPATH的主要作用是存放文件以便Golang程序编译时可以进行搜索引用，GOPATH可以设置一个值或多个值，多个值之间以分号隔开。很明显只要我们将本地Golang加入到GOPATH中即可在IDEA中正常运行该程序。</p><p>那么先<code>File--Settings--Languages &amp; Frameworks--Go--GOPATH</code>，在project GOPATH里添加<code>E:\github\GoeveryDay</code>这个总的文件路径，如图：<br><img src="/images/go5.png" alt="抱光妹"></p><p>apply保存即可，记住这里不能填<code>E:\github\GoeveryDay\src</code>，因为系统会自带src目录，如图：<br><img src="/images/go6.png" alt="抱光妹"></p><p>此时再执行就得到正确结果了！如图：<br><img src="/images/go7.png" alt="抱光妹"></p><p>但是要注意，<font color="red">要使用本地包函数、结构体、结构体的成员，首字母必须是大写！</font>如果首字母是小写是私有的，即不可见的，只能在同一个包里使用。</p>]]></content>
    
    <summary type="html">
    
      服务器临时禁止被ping的命令：echo 1 &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
      <category term="intellij idea" scheme="http://yoursite.com/tags/intellij-idea/"/>
    
  </entry>
  
  <entry>
    <title>Golang的切片学习笔记</title>
    <link href="http://yoursite.com/2019/07/03/Golang%E7%9A%84%E5%88%87%E7%89%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/03/Golang的切片学习笔记/</id>
    <published>2019-07-03T08:27:49.000Z</published>
    <updated>2019-07-04T12:19:59.845Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="与python对比">与python对比</span></h2><p>初开始接触golang的slice，感觉跟python的slice有点像，但也有几个比较明显的区别：</p><ol><li>python中的slice是在原有基础上拷贝一份。go中的slice则是指向生成它的数组/切片(切片和数组共用同一片内存)，切最长长度不会超限；</li><li>go的切片，其成员是相同类型的，python的列表和元组则不限制类型；</li><li>对于[a:b]这种切片操作，go的a、b两个参数不能是负数，python可以是负数，此时就相当于从末尾往前数；</li><li>对于[a:b:c]这种切片操作，go的c表示的是容量；而python的c表示的是步长。</li></ol><h2><span id="判断切片相等">判断切片相等</span></h2><p>比较两个切片是否相等，除了循环遍历还有一个<code>reflect</code>方法：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bijiao</span><span class="params">(b,c []<span class="keyword">int</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> reflect.DeepEqual(b,c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">b := []<span class="keyword">int</span>&#123;&#125;<span class="comment">//他俩是一回事</span></span><br><span class="line">c :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> d []<span class="keyword">int</span><span class="comment">//d跟b、c不是一回事</span></span><br><span class="line">fmt.Println(bijiao(b,c))</span><br><span class="line">fmt.Println(bijiao(d,c))</span><br><span class="line">fmt.Println(d)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="copy的问题">copy的问题</span></h2><p>go的copy是拷贝对应的位置，而不是全拷贝，也就是说如果是让一个空切片作为目的切片，那得到了新切片就是空切片，如果是让一个空切片做源切片，那么得到的新切片与目的切片一致。</p><h2><span id="判断字符串的几种情况">判断字符串的几种情况</span></h2><p>用一个例子说明：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"This is an example of a string."</span><span class="comment">//定义变量</span></span><br><span class="line">fmt.Printf(<span class="string">"T/F? Does the string \"%s\" have prefix %s? "</span>, str, <span class="string">"Th"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, strings.HasPrefix(str, <span class="string">"Th"</span>))</span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, strings.HasSuffix(str,<span class="string">"ing"</span>))</span><br><span class="line">fmt.Println(strings.Contains(str,<span class="string">"an"</span>))<span class="comment">//目标变量是否含有an</span></span><br><span class="line">fmt.Println(strings.ContainsAny(str,<span class="string">"axwq"</span>))<span class="comment">//目标变量是否含有“axwq”里的任意一个</span></span><br><span class="line">fmt.Println(strings.Count(str, <span class="string">"s"</span>))<span class="comment">//目标变量里有多少个s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要获取汉字字符串的汉字数，可以使用<code>utf8.RuneCountInString(s)</code>。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://studygolang.com/articles/12944" target="_blank" rel="noopener">https://studygolang.com/articles/12944</a> （判断相等的deepequal）<br><a href="https://studygolang.com/articles/5769" target="_blank" rel="noopener">https://studygolang.com/articles/5769</a>  （golang中strings包用法）</p>]]></content>
    
    <summary type="html">
    
      golang判断map里是否含有某个key，可以使用if val, ok := dict[&quot;foo&quot;]的方法
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>一个Go语言按行读取文件的脚本</title>
    <link href="http://yoursite.com/2019/07/02/Go%E8%AF%AD%E8%A8%80flag%E5%8C%85%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/07/02/Go语言flag包学习/</id>
    <published>2019-07-02T02:56:00.000Z</published>
    <updated>2019-07-02T13:21:33.681Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="脚本内容">脚本内容</span></h2><p>假设我有一个文件111.txt，内容如下：<br><img src="/images/go3.png" alt="akb48"></p><p>现在需要读取这个111.txt，并将文件里的数值，然后组合成一个数列，再写入到222.txt里。写了一个go脚本flagtest.go，内容如下：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> infile *<span class="keyword">string</span> = flag.String(<span class="string">"i"</span>,<span class="string">"infile"</span>,<span class="string">"file contains vales for sorting"</span>)<span class="comment">//flag 包中，定义的指令以指针类型返回</span></span><br><span class="line"><span class="keyword">var</span> outfile *<span class="keyword">string</span> = flag.String(<span class="string">"o"</span>,<span class="string">"outfile"</span>,<span class="string">"file to receive sorted values"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readValues</span><span class="params">(infile <span class="keyword">string</span>)</span><span class="params">(values []<span class="keyword">int</span>,err error)</span></span>&#123;</span><br><span class="line">file, err := os.Open(infile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"failed to open this file:"</span>,infile)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> file.Close()<span class="comment">//资源释放,关闭文件句柄</span></span><br><span class="line"><span class="comment">//file.Close()不会触发panic，会先判断file == nil</span></span><br><span class="line"><span class="comment">//defer 除了最后执行之外还有一个重要的特性：即便函数抛出了异常，也会被执行的。 这样就不会因程序出现了错误，而导致资源不会释放了</span></span><br><span class="line"></span><br><span class="line">br := bufio.NewReader(file)<span class="comment">//读缓冲区</span></span><br><span class="line"></span><br><span class="line">values = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)<span class="comment">//空切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">line,isPrefix,err1 := br.ReadLine()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">if</span> err1 != io.EOF &#123;</span><br><span class="line">err = err1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isPrefix &#123;</span><br><span class="line">fmt.Println(<span class="string">"A too long line,seems unexpected."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str := <span class="keyword">string</span>(line)  <span class="comment">//转换字符数组成字符串</span></span><br><span class="line"></span><br><span class="line">value,err1 := strconv.Atoi(str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">err = err1</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">values = <span class="built_in">append</span>(values,value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(values)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeVaules</span><span class="params">(values []<span class="keyword">int</span>, outfile <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">file, err := os.Create(outfile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"创建文件失败！"</span>,outfile)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,value := <span class="keyword">range</span> values &#123;<span class="comment">//第一个是下标，第二个是元素</span></span><br><span class="line">str := strconv.Itoa(value)<span class="comment">//int到string</span></span><br><span class="line">file.WriteString(str + <span class="string">"\n"</span>)<span class="comment">//如果是windows文件，那就是\r\n</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="keyword">if</span> infile != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"infile ="</span>,*infile,<span class="string">"outfile ="</span>,*outfile)</span><br><span class="line">&#125;</span><br><span class="line">values,err := readValues(*infile)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"原文件的内容是:"</span>, values)</span><br><span class="line">fmt.Println(<span class="string">"现在开始录入到新文件里..."</span>)</span><br><span class="line">writeVaules(values, *outfile)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行效果如下：<br><img src="/images/go2.png" alt="akb48"></p><h2><span id="新的知识点">新的知识点！</span></h2><ol><li><code>bufio.NewReader</code>的返回值里<code>line</code>和<code>err</code>不可能同时<code>非nil</code>。</li><li><code>string</code>方法会自动识别\n和\t等通配符。</li><li><code>reader.ReadBytes（&quot;\n&quot;)</code>这个方法可以将字符串按\n分割，然后取第一部分。</li><li>读取一行，通常会选择<code>ReadBytes</code>或<code>ReadString</code>。不过，正常人的思维，应该用<code>ReadLine</code>，只是不明白为啥ReadLine的实现不是通过ReadBytes，然后清除掉行尾的<code>\n</code>（或<code>\r\n</code>），它现在的实现，用不好会出现意想不到的问题，比如丢数据。个人建议可以这么实现读取一行： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line, err := reader.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">line := bytes.TrimRight(line, <span class="string">"\r\n"</span>)</span><br></pre></td></tr></table></figure></li></ol><p>这样既读取了一行，也去掉了行尾结束符（当然，如果你希望留下行尾结束符，只用ReadBytes即可）。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://segmentfault.com/a/1190000014935402" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014935402</a><br><a href="http://qefee.com/2014/02/02/go%E8%AF%AD%E8%A8%80%E7%9A%84flag%E5%8C%85%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">http://qefee.com/2014/02/02/go%E8%AF%AD%E8%A8%80%E7%9A%84flag%E5%8C%85%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</a> (flag各种用法集合）<br><a href="http://fuxiaohei.me/2015/12/9/mistake-in-bufio-reader.html" target="_blank" rel="noopener">http://fuxiaohei.me/2015/12/9/mistake-in-bufio-reader.html</a> （bufio.reader的坑）<br><a href="https://github.com/ma6174/blog/issues/10" target="_blank" rel="noopener">https://github.com/ma6174/blog/issues/10</a> （bufio.reader的坑2）<br><a href="https://studygolang.com/articles/5932" target="_blank" rel="noopener">https://studygolang.com/articles/5932</a> （go使用Defer的几个场景）</p>]]></content>
    
    <summary type="html">
    
      取地址操作符&amp;和取值操作符*是一对互补操作符，&amp;取出地址，*根据地址取出地址指向的值。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Linux运维工程师笔试题第十九套</title>
    <link href="http://yoursite.com/2019/07/01/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%A5%97/"/>
    <id>http://yoursite.com/2019/07/01/Linux运维工程师笔试题第十九套/</id>
    <published>2019-07-01T02:31:06.000Z</published>
    <updated>2019-07-02T05:55:27.036Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="试题内容">试题内容</span></h2><ol><li><p>简述一下客户端请求网页里a.css的过程。<br><img src="/images/css5.png" alt="akb48"></p></li><li><p>HTTP 协议中与缓存相关的<code>HTTP Header</code>有哪些?<br>见<a href="https://segmentfault.com/a/1190000014445687?utm_source=index-hottest/*&amp;^%$" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014445687?utm_source=index-hottest/*&amp;^%$</a> 这篇文章吧。</p></li><li><p>SQL语句：<code>update apps set ID=&quot;12345&quot; and NAME=&quot;李四&quot; where ID=&quot;11111&quot; and NAME=&quot;张三&quot;</code>的执行结果是什么？为什么会有这个结果？<br><img src="/images/css6.png" alt="akb48"></p></li></ol><p>mysql官方要求以逗号分隔的<code>col_name=value</code>列表，如果是and的话，题目中的句子实际执行效果是<code>update apps set ID=（&quot;12345&quot; and NAME=&quot;李四&quot;） where ID=&quot;11111&quot; and NAME=&quot;张三&quot;</code>，即括号里的是一个逻辑表达式，但是由于NAME是等于张三而不是李四，于是就等于<code>ID=&quot;12345&quot; and False</code>，即False，在mysql里False等于0。所以出现了这个情况。</p><ol><li><p>接上题，如果要正确达到目的应该怎么写？<br>正确写法是：<code>update apps set Id=&quot;12345&quot;，NAME=&quot;李四&quot; where ID=&quot;11111&quot; and NAME=&quot;张三&quot;</code>，这样才能达到同时修改两个列的目的。</p></li><li><p>POST和GET的区别<br>见<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener">https://www.cnblogs.com/logsharing/p/8448446.html</a> 这篇文章吧。</p></li><li><p>如何保证用户鉴权过程是安全的？<br>用户在网页输入用户名A和密码B，对“A+B+有规律的字符串”进行加密得到C，将A和C传递给服务器。由于A是明文的，服务器可根据A去数据库里得到相应的密码B，也用同样的步骤生成D，比较C和D是否相同即可。</p></li><li><p>Lunix如何查看某个进程的线程？<br>两种方法：<br>1）<code>ps -T -p pid</code>，返回的结果里spid就是线程号<br>2）<code>top -H -p pid</code><br>3）<code>pstree -p 进程用户名 | grep 进程名</code>，<code>ps -Lf 进程名</code>，<code>pstack 进程名</code></p></li><li><p>数据库事务隔离级别<br>数据库事务的隔离级别有4个，由低到高依次为<code>Read uncommitted（</code>读未提交） 、<code>Read committed</code>（读提交，SQL和ORACLE的默认规则） 、<code>Repeatable read</code>（重复读，MYSQL默认的） 、<code>Serializable</code>（序列化，效率低但是最准确） ，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p></li><li><p>将软连接的原文件删除，能否编辑此软连接？会有什么现象？<br>可以通过echo命令编辑此软连接，结果生成名跟原文件一样的文件，inode也一样，但是文件内容已经是echo的新内容了。</p></li><li><p>如何识别此文件是硬链接？<br>使用ll -hit查看文件，如果索引数不是1就是硬链接。</p></li><li><p>数据库延迟同步的语句是什么？<br>一般来说为了防止数据库误操作，都会给一个异地备份数据库配置延迟同步功能，语句如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;stop slave;</span><br><span class="line">mysql&gt;CHANGE MASTER TO MASTER_DELAY = <span class="number">1800</span>；单位为秒</span><br><span class="line">mysql&gt;start slave;</span><br></pre></td></tr></table></figure></li><li><p>SQL语句执行很慢的原因都有什么？<br>见<a href="https://zhuanlan.zhihu.com/p/62941196" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62941196</a> 这篇文章。</p></li></ol><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/kaiye/kaiye.github.com/issues/3" target="_blank" rel="noopener">https://github.com/kaiye/kaiye.github.com/issues/3</a><br><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/08/20/innodb-lock.html</a> （Innodb中的事务隔离级别和锁的关系）</p>]]></content>
    
    <summary type="html">
    
      主键索引和非主键索引是有区别的，主键索引存放的值是整行字段的数据，而非主键索引上存放的值不是整行字段的数据，而且存放主键字段的值。
    
    </summary>
    
      <category term="大牛之路" scheme="http://yoursite.com/categories/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="http网络" scheme="http://yoursite.com/tags/http%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Proxysql添加后端SSL加密</title>
    <link href="http://yoursite.com/2019/06/28/Proxysql%E6%B7%BB%E5%8A%A0%E5%90%8E%E7%AB%AFSSL%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2019/06/28/Proxysql添加后端SSL加密/</id>
    <published>2019-06-28T02:45:53.000Z</published>
    <updated>2019-07-01T02:30:23.333Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="配置正文">配置正文</span></h2><p>安全部门最近放出了新需求，要数据库流量实现内网加密。即<code>mysql&lt;-----&gt;proxysql</code>之间是加密的，这里记录整个配置过程，安装部分可以移步去看 <a href="https://rorschachchan.github.io/2019/05/31/%E8%AE%B0%E5%BD%95%E9%83%A8%E7%BD%B2ProxySql%E7%9A%84%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">https://rorschachchan.github.io/2019/05/31/%E8%AE%B0%E5%BD%95%E9%83%A8%E7%BD%B2ProxySql%E7%9A%84%E8%BF%87%E7%A8%8B/</a> 这篇文章。</p><p>首先登陆阿里云控制台RDS，选择对应的数据库—数据安全性—SSL，点击<code>开通</code>，如图：<br><img src="/images/proxy27.png" alt="akb48"></p><font color="red">注意！此项举动会重启数据库，所以线上环境请慎重！</font><p>在配置的时候，同时下载CA证书，上传到proxysql所在的服务器的<code>/var/lib/proxysql/</code>里。解压缩之，发现压缩包里是三个文件，如图：<br><img src="/images/proxy28.png" alt="akb48"></p><p>我们主要用的是<code>ApsaraDB-CA-Chain.pem</code>这个文件（如果是读写库，那么这个pem的文件是一模一样的）。</p><p>如果数据库开通ssl成功，那么在阿里云的控制台上是显示为“已开通”，在mysql命令行里使用<code>show global variables like &#39;%ssl%&#39;;</code>查看如下：<br><img src="/images/proxy30.png" alt="akb48"></p><p>登录proxysql，查看当前链接mysql情况，如图：<br><img src="/images/proxy29.png" alt="akb48"></p><p>发现里面的<code>use_ssl</code>是0，所以<code>update mysql_servers set use_ssl=1;</code>将他们改成1。</p><p>然后<code>set mysql-ssl_p2s_ca = &#39;/var/lib/proxysql/ApsaraDB-CA-Chain.pem&#39;;</code>设定CA证书所在路径。随后就是<code>load mysql variables to runtime;</code>和<code>save mysql variables to disk;</code>，保存之后使用<code>select * from runtime_global_variables;</code>查看：<br><img src="/images/proxy31.png" alt="akb48"></p><p>验证的方法也很简单，在对应数据库里操作的同时<code>tcpdump -s 0 -i any -v port 3306 -w /root/test.pcap</code> 抓一下包看一下里面的内容是否加密了就行。</p><p>补充：虽然SSL方式使得安全性提高了，但是相对地使得QPS也降低23%左右。所以要谨慎选择：</p><ol><li>对于非常敏感核心的数据，或者QPS本来就不高的核心数据，可以采用SSL方式保障数据安全性；</li><li>对于采用短链接、要求高性能的应用，或者不产生核心敏感数据的应用，性能和可用性才是首要，建议不要采用SSL方式；</li></ol><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/sysown/proxysql/wiki/SSL-Support" target="_blank" rel="noopener">https://github.com/sysown/proxysql/wiki/SSL-Support</a><br><a href="https://googlebaba.io/mysqlcookbook/7.aboutssl.html" target="_blank" rel="noopener">https://googlebaba.io/mysqlcookbook/7.aboutssl.html</a></p><p><img src="/images/DH12-2.gif" alt="akb48" title="2009年东部半决赛魔术VS骑士"></p>]]></content>
    
    <summary type="html">
    
      以通配符（%）开始的like字符串，走索引。比如like %aaa%会使用索引，而like aaa%不会
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读写分离" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
      <category term="proxysql" scheme="http://yoursite.com/tags/proxysql/"/>
    
      <category term="ssl加密" scheme="http://yoursite.com/tags/ssl%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Ansible-Playbook判断进程是否存在</title>
    <link href="http://yoursite.com/2019/06/27/Ansible-Playbook%E5%88%A4%E6%96%AD%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"/>
    <id>http://yoursite.com/2019/06/27/Ansible-Playbook判断进程是否存在/</id>
    <published>2019-06-27T13:57:14.000Z</published>
    <updated>2019-06-28T09:03:14.067Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>部署有一个需求，要将所有的模块服务器里添加一个叫agentmizar的日志采集模块。但是有一些服务器提前有部署过，那么判断一下如果服务器里有此进程就跳过，如果没有此进程就传包并修改配置文件然后启动。</p><p>与playbook搭配的yaml内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- hosts: all<span class="comment">#默认执行hosts里的所有IP</span></span><br><span class="line">  remote_user: root</span><br><span class="line">  any_errors_fatal: no</span><br><span class="line">  gather_facts: no<span class="comment">#不采集对方机器的数据，提高执行速度</span></span><br><span class="line">  serial:</span><br><span class="line">  - <span class="number">5</span><span class="comment">#5台机器一组</span></span><br><span class="line">  tasks:</span><br><span class="line">  - name: judge agent process <span class="keyword">is</span> exits</span><br><span class="line">    shell: ps -aux | grep agent</span><br><span class="line">    ignore_errors: <span class="keyword">True</span><span class="comment">#如果命令执行不成功，即 echo $?不为0，则在其语句后面的ansible语句不会被执行，导致整个程序中止。</span></span><br><span class="line">    register: result</span><br><span class="line"></span><br><span class="line">  - name: agent <span class="keyword">is</span> running</span><br><span class="line">    shell: echo <span class="string">"agent is running"</span></span><br><span class="line">    when: result.stdout.find(<span class="string">'agent.conf'</span>) != <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">  - name: agent dir <span class="keyword">is</span> exits</span><br><span class="line">    shell: ls /opt/agentmizar</span><br><span class="line">ignore_errors: <span class="keyword">True</span></span><br><span class="line"> register: dirresult</span><br><span class="line"></span><br><span class="line">  - name: copy packages</span><br><span class="line">    copy:</span><br><span class="line">      src: /tmp/agentmizar.zip</span><br><span class="line">      dest: /opt</span><br><span class="line">      owner: root</span><br><span class="line">    when: dirresult <span class="keyword">is</span> failed<span class="comment">#如果文件夹存在就是dirresult is succeeded</span></span><br><span class="line"> </span><br><span class="line">  - name: unzip agentmizar</span><br><span class="line">    unarchive:</span><br><span class="line">      <span class="comment">#extra_opts: -j#将zip里的所有递归文件都放到本目录</span></span><br><span class="line">      src: /opt/agentmizar.zip</span><br><span class="line">      dest: /opt  </span><br><span class="line">      remote_src: yes </span><br><span class="line">    when: result.stdout.find(<span class="string">'agent.conf'</span>) == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">  - name: backup old <span class="keyword">and</span> unpack new package</span><br><span class="line">    shell: cp -rf /opt/build/* /opt/<span class="comment">#由于zip包也解压缩出来是一个build文件夹，需要再扒一层</span></span><br><span class="line">    when: result.stdout.find(<span class="string">'agent.conf'</span>) == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">  - name: update agent.conf</span><br><span class="line">    lineinfile:</span><br><span class="line">      dest: /opt/agentmizar/agent.conf</span><br><span class="line">      regexp: <span class="string">"kafka = 192.168.0.1:9092,192.168.0.2:9092,192.168.0.3:9092"</span><span class="comment">#修改配置文件</span></span><br><span class="line">      line: <span class="string">"kafka = 172.0.10.1:9092"</span></span><br><span class="line">    when: result.stdout.find(<span class="string">'agent.conf'</span>) == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">  - name: start agentmizar</span><br><span class="line">    shell: cd /opt/agentmizar/ &amp;&amp; /bin/bash /opt/agentmizar/start_agent.sh</span><br><span class="line">    when: result.stdout.find(<span class="string">'agent.conf'</span>) == <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>这个yaml，我执行<code>ps -aux | grep agent</code>，并将结果存储到<code>result</code>这个<code>register</code>里。然后从<code>register</code>里去find关键字<code>agent.conf</code>，如果不存在就返回-1，那么可以判断当前机器里没有agentmizar进程。</p><p>如果说进程是一个守护进程，那么在判断进程（比如是systemctl status apache2）是否存在可以这么写：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- name: Check <span class="keyword">if</span> Apache <span class="keyword">is</span> running</span><br><span class="line">  command: systemctl status apache2</span><br><span class="line">  ignore_errors: yes</span><br><span class="line">  changed_when: false</span><br><span class="line">  register: service_apache_status</span><br><span class="line"></span><br><span class="line">- name: Report status of Apache</span><br><span class="line">  fail:</span><br><span class="line">    msg: |</span><br><span class="line">      Service apache2 <span class="keyword">is</span> <span class="keyword">not</span> running.</span><br><span class="line">      Output of `systemctl status apache2`:</span><br><span class="line">      &#123;&#123; service_apache_status.stdout &#125;&#125;</span><br><span class="line">      &#123;&#123; service_apache_status.stderr &#125;&#125;</span><br><span class="line">  when: service_apache_status | failed</span><br></pre></td></tr></table></figure></p><p>注意！如果when条件判断句中有变量的话要将用（）来括变量，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">when: ansible_default_ipv4.address == &#123;&#123; ETCD_NODE03 &#125;&#125;<span class="comment">#错误写法</span></span><br><span class="line">when: ansible_default_ipv4.address == (ETCD_NODE03)<span class="comment">#正确写法</span></span><br></pre></td></tr></table></figure></p><p>再注意！<code>register</code>变量的命名不能用-（中横线），比如<code>dev-sda6_result</code>，则会被解析成<code>sda6_result</code>，dev会被丢掉！</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/1608_lih_ansible/index.html</a><br><a href="https://blog.51cto.com/liuzhengwei521/1962382" target="_blank" rel="noopener">https://blog.51cto.com/liuzhengwei521/1962382</a>    （条件判断）<br><img src="/images/DH12-1.gif" alt="akb48" title="2009年东部半决赛魔术VS骑士"></p>]]></content>
    
    <summary type="html">
    
      如果遇到文件模式是dos的话，执行set ff=unix即可。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ansible" scheme="http://yoursite.com/tags/ansible/"/>
    
      <category term="批量部署" scheme="http://yoursite.com/tags/%E6%89%B9%E9%87%8F%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python端口探测脚本</title>
    <link href="http://yoursite.com/2019/06/25/Python%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/06/25/Python端口探测脚本/</id>
    <published>2019-06-25T14:22:23.000Z</published>
    <updated>2019-06-26T03:55:31.587Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>有一个模块最近总是假死，假死的现象就是进程还在但是端口（9030端口）已经不工作了。于是就需要写一个端口探测脚本，发现该端口一旦无法正常收到信息，就重启此模块。</p><p>由于此模块是一个五台机器的集群，我这次没有在五台机器都跑一样的脚本，而是在一个可以免密码ssh到他们的机器上写了一个脚本，让这个机器去探测对应的端口。模式如图：<br><img src="/images/yum5.png" alt="akb48"></p><p>先创建一个<code>detect.conf</code>如下，他的格式是yaml，所以不要用tab用空格：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">    Name: localhost</span><br><span class="line">    IP: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br><span class="line">---</span><br><span class="line">    Name: mrs<span class="number">-05</span></span><br><span class="line">    IP: <span class="number">10.0</span><span class="number">.1</span><span class="number">.14</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br><span class="line">---</span><br><span class="line">    Name: mrs<span class="number">-04</span></span><br><span class="line">    IP: <span class="number">10.0</span><span class="number">.1</span><span class="number">.13</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br><span class="line">---</span><br><span class="line">    Name: mrs<span class="number">-03</span></span><br><span class="line">    IP: <span class="number">10.0</span><span class="number">.1</span><span class="number">.12</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br><span class="line">---</span><br><span class="line">    Name: mrs<span class="number">-02</span></span><br><span class="line">    IP: <span class="number">10.0</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line">    Port: <span class="number">9030</span></span><br></pre></td></tr></table></figure></p><p>脚本<code>detect.py</code>内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 作者：ChrisChan</span></span><br><span class="line"><span class="comment"># 用途：Python3.6脚本，检测IP端口连接是否正常,建议放在单独的机器里进行端口扫描，此脚本需要搭配同目录下的detect.conf使用。</span></span><br><span class="line"><span class="comment"># 请先pip install PyYaml,pip install paramiko</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh秘钥地址</span></span><br><span class="line">key_filename = <span class="string">"秘钥地址,即id_rsa"</span></span><br><span class="line"><span class="comment"># 重启进程命令</span></span><br><span class="line">command = <span class="string">"具体的进程启动命令"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_open</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.connect((ip, int(port)))</span><br><span class="line">        s.shutdown(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ssh</span><span class="params">(ip)</span>:</span></span><br><span class="line">    ssh = paramiko.SSHClient()</span><br><span class="line">    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ssh.connect(ip, <span class="number">22</span>, <span class="string">"appuser"</span>, key_filename=key_filename)<span class="comment">#这里写死了22端口和appuser用户</span></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'私钥文件不存在！'</span>)</span><br><span class="line">    <span class="keyword">except</span> AuthenticationException <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'私钥不正确，请检查对应用户或私钥内容！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stdin, stdout, stderr = ssh.exec_command(command)</span><br><span class="line">        print(stdout.readlines())</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        ssh.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    input = open(<span class="string">'detect.conf'</span>, <span class="string">'r'</span>)    <span class="comment"># 这里是pyyaml 5.1的新格式</span></span><br><span class="line">    ys = yaml.load_all(input, Loader=yaml.FullLoader)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> ys:</span><br><span class="line">        host = y[<span class="string">"IP"</span>]<span class="comment">#从yaml里取值</span></span><br><span class="line">        port = y[<span class="string">"Port"</span>]</span><br><span class="line">        <span class="keyword">if</span> is_open(host, port):</span><br><span class="line">            print(y[<span class="string">"Name"</span>] + <span class="string">" is OK"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(y[<span class="string">"Name"</span>] + <span class="string">" is NO"</span>)</span><br><span class="line">            ssh(host)</span><br><span class="line">            print(<span class="string">"Process is started!"</span>)</span><br></pre></td></tr></table></figure></p><p>内网探测效果还不错，如果时间耗时比较长，就放弃for循环，走多进程路线更佳！<br><img src="/images/yum6.png" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      想查看文件里隐藏文件的大小，使用命令:du -sh * .[^.]*
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python3" scheme="http://yoursite.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>使用Alpine当基础镜像的坑</title>
    <link href="http://yoursite.com/2019/06/24/%E4%BD%BF%E7%94%A8Alpine%E5%BD%93%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2019/06/24/使用Alpine当基础镜像的坑/</id>
    <published>2019-06-24T09:09:32.000Z</published>
    <updated>2019-06-26T14:41:58.431Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="踩坑正文">踩坑正文</span></h2><p>今天部署开发要上一个新模块，此模块已经通过golang编译好的，而且在本地机器可以正常启动，现在需要将其容器化—-制作一个镜像，然后在根据这个镜像启动程序。</p><p>本着基础镜像最小的原则，就选择了<code>alpine:latest</code>。先创建一个干净的alpine镜像挂载模块所在的文件夹，然后<code>docker exec</code>进去执行启动脚本。发现启动脚本里涉及到了<code>cpulimit</code>、<code>rpm</code>、<code>ps -p</code>、 <code>sudo</code>等alpine非自带命令所以无法启动。alpine安装模块的命令即非<code>yum</code>又非<code>apt-get</code>，而是<code>apk add</code>，于是在Dockerfile里添加一句：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apk add cpulimit &amp;&amp; apk add rpm &amp;&amp; apk add sudo &amp;&amp; apk --update add procps</span><br></pre></td></tr></table></figure></p><p>新镜像制作完毕，进去启动还是失败。具体表现是<code>./启动脚本</code>的时候报<code>&quot;no such file or directory&quot;</code>，开始我以为是因为alpine没有<code>/bin/bash</code>的缘故，把所有的shebang都改成了<code>/bin/sh</code>。但是发现启动的时候报格式错误，我想到这是一个go编译好的脚本，那么<code>./</code>就应该可以直接启动的。后来在<a href="https://github.com/gin-gonic/gin/issues/1178" target="_blank" rel="noopener">https://github.com/gin-gonic/gin/issues/1178</a> 里查到原来alpine里是没有稳定的libc，所以还要添加<code>libc6-compat</code>和<code>libstdc++</code>。</p><p>在镜像里<code>apk add libc6-compat &amp;&amp; apk add libstdc++</code>之后，发现启动脚本还有这样一句话：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">'./core_%e.%p'</span> | sudo tee /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></p><p>这个命令是无法执行的，因为docker里<code>/proc/sys/kernel/core_pattern</code>是只读文件，自然无法进行修改。但是宿主机上的这个文件是root用户可以修改的。这可怎么办？</p><p>我开始想既然宿主机的<code>/proc/sys/kernel/core_pattern</code>可以修改，那么就把宿主机的<code>/proc/sys/kernel/core_pattern</code>挂载给镜像不就得了？但是在执行的时候会报错：<code>cannot be mounted because it is located inside “/proc”</code>，因为Docker不允许在<code>proc</code>目录下随意挂文件，如果你有信心可以通过修改docker的源码来实现挂载的效果。</p><p>但是我觉得还是沉稳为上，于是就想出一个办法：在docker run的时候添加<code>--privileged</code>，这样容器获得了额外的特权可以对系统变量的值进行修改。但是要注意如果容器发生了重启，那么值会恢复成原样，即无法持久化。不过在启动脚本里已经有了echo语句，这样每一次执行启动脚本都会更改<code>/proc/sys/kernel/core_pattern</code>，于是就不用太担心这个问题了。</p><p>最后完整的Dockerfile如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">MAINTAINER ChrisChan &lt;<span class="number">33664</span>@dahuatech.com&gt;</span><br><span class="line"></span><br><span class="line">RUN apk update &amp;&amp; apk add libc6-compat &amp;&amp; apk add libstdc++ &amp;&amp; apk add cpulimit &amp;&amp; apk add rpm &amp;&amp; apk add sudo &amp;&amp; apk --update add procps</span><br><span class="line">RUN mkdir -p /mnt/agentmizar<span class="comment">#agentmizar这个就是工作的模块名</span></span><br><span class="line">WORKDIR /mnt/agentmizar<span class="comment">#设定工作目录</span></span><br><span class="line">CMD [<span class="string">"sh"</span>, <span class="string">"control"</span>, <span class="string">"start"</span>]<span class="comment">#启动之</span></span><br></pre></td></tr></table></figure></p><p>创建完镜像之后，启动语句如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name 容器名 -dit  -v /opt/:/opt/:ro -v /etc/localtime:/etc/localtime:ro --privileged 镜像名<span class="comment">#别忘了对准时间</span></span><br></pre></td></tr></table></figure></p><p>补充一句，最后镜像大小不到50MB。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/qq_41980563/article/details/88876874" target="_blank" rel="noopener">https://blog.csdn.net/qq_41980563/article/details/88876874</a><br><a href="https://serverfault.com/questions/883625/alpine-shell-cant-find-file-in-docker" target="_blank" rel="noopener">https://serverfault.com/questions/883625/alpine-shell-cant-find-file-in-docker</a><br><a href="https://sq.163yun.com/blog/article/155817999160799232" target="_blank" rel="noopener">https://sq.163yun.com/blog/article/155817999160799232</a></p>]]></content>
    
    <summary type="html">
    
      卷扩容时使用resize2fs出现Bad magic number in super-block while trying to open的错误，可使用xfs_growfs破之
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>研究一下Zabbix 3.4的服务主动发现功能</title>
    <link href="http://yoursite.com/2019/06/21/%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8BZabbix-3-4%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%BB%E5%8A%A8%E5%8F%91%E7%8E%B0%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2019/06/21/研究一下Zabbix-3-4的服务主动发现功能/</id>
    <published>2019-06-21T09:24:11.000Z</published>
    <updated>2019-06-24T03:02:11.431Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我所在组一直以来对不同服务的监控方针是：针对不同的服务（比如nginx,tomcat,mysql等等）创建不同的template，然后将这个template应用于对应的服务器上，在每一个template里添加具体的item和trigger。今天尝试一下全新的自动发现<code>Low-level discovery</code>（LLD）。</p><p>LLD对返回的内容有一个json格式，这个json格式必须要被<code>zabbix-server</code>识别。所以我们需要准备一个脚本，脚本的结果就是生成这个json。本文<code>zabbix-server</code>和<code>zabbix-agent</code>的版本都是<code>3.4.15</code>。</p><h2><span id="服务器内部操作">服务器内部操作</span></h2><p>首先在被监控服务器里，创建一个脚本<code>/etc/zabbix/script/discovery_services.sh</code>，内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">proarray=($(find /var/run/ -name <span class="string">"*.pid"</span>|egrep -v <span class="string">'(rpc|php_daemon|haldaemon|irqbalance|console-kit-daemon)'</span> |awk -F<span class="string">'/'</span> <span class="string">'&#123;print $NF&#125;'</span>|awk -F<span class="string">'.'</span> <span class="string">'&#123;print $1&#125;'</span>))    <span class="comment"># 排除不监控的服务</span></span><br><span class="line"></span><br><span class="line">length=$&#123;<span class="comment">#proarray[@]&#125;#$&#123;#var&#125;是用来取长度</span></span><br><span class="line">printf <span class="string">"&#123;\n"</span></span><br><span class="line">printf  <span class="string">'\t'</span><span class="string">"\"data\":["</span></span><br><span class="line">printf <span class="string">"\t"</span></span><br><span class="line">printf <span class="string">'\n\t\t&#123;'</span></span><br><span class="line">printf <span class="string">"\"&#123;#PRO_NAME&#125;\":\"iptables\"&#125;"</span>       <span class="comment">#必须要添加的iptables</span></span><br><span class="line">printf  <span class="string">","</span></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;$length;i++))</span><br><span class="line">do</span><br><span class="line">        printf <span class="string">'\n\t\t&#123;'</span></span><br><span class="line">        printf <span class="string">"\"&#123;#PRO_NAME&#125;\":\"$&#123;proarray[$i]&#125;\"&#125;"</span><span class="comment">#for循环取每一项</span></span><br><span class="line">        <span class="keyword">if</span> [ $i -lt $[$length<span class="number">-1</span>] ];then</span><br><span class="line">                printf <span class="string">','</span></span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">printf  <span class="string">"\n\t]\n"</span></span><br><span class="line">printf <span class="string">"&#125;\n"</span></span><br></pre></td></tr></table></figure></p><p>这里我们设定将所有的进程文件的pid统一放到/var/run下，这样能取到所有进程的文件。脚本里的<code>{PRO_NAME}</code>这个就是自动发现规则中的宏变量，另外这个脚本返回的是符合<code>zabbix-server</code>的json格式。如图：<br><img src="/images/LLD7.png" alt="akb48"></p><p>同时在加上一个判断进程是否运行的脚本<code>/etc/zabbix/script/program_status.sh</code>，内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">procjetName=<span class="string">"$&#123;1:-NULL&#125;"</span></span><br><span class="line">LOCK_PATH=<span class="string">"/var/lock/subsys"</span>     </span><br><span class="line">RUN_PATH=<span class="string">"/var/run"</span></span><br><span class="line">ret_ok=<span class="number">1</span></span><br><span class="line">ret_critical=<span class="number">3</span></span><br><span class="line">ret_unknown=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  [[ $&#123;procjetName&#125; == <span class="string">"NULL"</span> ]] ; then</span><br><span class="line">        echo $&#123;ret_unknown&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"$&#123;LOCK_PATH&#125;/$&#123;procjetName&#125;"</span> ] || [ -f <span class="string">"$&#123;RUN_PATH&#125;/$&#123;procjetName&#125;.pid"</span> ]  || [ -f <span class="string">"$&#123;RUN_PATH&#125;/$&#123;procjetName&#125;/$&#123;procjetName&#125;.pid"</span> ] ; then</span><br><span class="line">        echo $&#123;ret_ok&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        echo $&#123;ret_critical&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>这个脚本的结果就是：服务若存在就返回1，否则返回3。如图：<br><img src="/images/LLD8.png" alt="akb48"></p><p>然后在<code>zabbix_agentd.conf</code>里添加两个<code>items</code>，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=services.scan,/bin/bash /etc/zabbix/script/discovery_services.sh</span><br><span class="line">UserParameter=services.status[*],/bin/bash /etc/zabbix/script/program_status.sh $<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>服务端操作到此结束。</p><h2><span id="web端操作">WEB端操作</span></h2><p>添加自动发现规则与添加item很相似，先<code>configuation</code>—<code>templates</code>—<code>create template</code>:<br><img src="/images/LLD1.png" alt="akb48"></p><p><img src="/images/LLD2.png" alt="akb48"></p><p>在新生成的“服务进程自动发现”的template里添加<code>Discovery rules</code>，设定Key是<code>Services.scan</code>如下：<br><img src="/images/LLD3.png" alt="akb48"></p><p>上面那个<code>Services.scan</code>到时候要写到<code>zabbix-agent.conf</code>里的，切记保持一模一样。然后在点击Filters标签页，如下：<br><img src="/images/LLD4.png" alt="akb48"></p><p>此处的<code>{PRO_NAME}</code>就是我们的脚本返回的变量，保存之。然后创建一个<code>item prototypes</code>，如图：<br><img src="/images/LLD5.png" alt="akb48"></p><p>此处需要注意的<code>$1</code>和<code>键值</code>是我们之前定义的，也即是服务名，保存之。</p><p>然后创建一个<code>trigger prototype</code>，如图：<br><img src="/images/LLD6.png" alt="akb48"></p><p>图中的解释器是：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;auto Service discovery:services.status[&#123;<span class="comment">#PRO_NAME&#125;].last()&#125;&lt;&gt;1) and (&#123;auto Service discovery:services.status[&#123;#PRO_NAME&#125;].last(,1h)&#125;=1)</span></span><br></pre></td></tr></table></figure></p><p>这句话的意思是“最后状态不是1同时一小时前的状态是1”的服务出现了问题会发生报警，这主要是因为当启动一些临时进程，比如yum，当yum完毕了之后，进程就不存在了，那么如果只是通过判断进程数的话，就会报<code>yum is down</code>。</p><p>至此web端配置结束。</p><h2><span id="错误解决">错误解决</span></h2><p>如果web界面出现了<code>Value should be a JSON object.</code>的错误，如图：<br><img src="/images/LLD9.png" alt="akb48"></p><p>跑到zabbix-server去zabbix-get一下发现有错误：<br><img src="/images/LLD10.png" alt="akb48"></p><p>将mdadm这个文件夹改成755即可。回到web页面查看一下<code>latest data</code>:<br><img src="/images/LLD11.png" alt="akb48"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.zabbix.com/documentation/3.4/zh/manual/discovery/low_level_discovery" target="_blank" rel="noopener">https://www.zabbix.com/documentation/3.4/zh/manual/discovery/low_level_discovery</a><br><a href="https://www.xiaomastack.com/2015/07/04/zabbix-auto-tcp-port/" target="_blank" rel="noopener">https://www.xiaomastack.com/2015/07/04/zabbix-auto-tcp-port/</a><br><a href="https://www.cnblogs.com/fengbohello/p/5954895.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengbohello/p/5954895.html</a> （Linux Shell 截取字符串）<br><a href="http://caosiyang.github.io/2017/03/06/zabbix-get-value-error/" target="_blank" rel="noopener">http://caosiyang.github.io/2017/03/06/zabbix-get-value-error/</a></p>]]></content>
    
    <summary type="html">
    
      AWS的工单反馈与阿里云真是天差地别
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="监控" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>网易雷火运维面试全纪录</title>
    <link href="http://yoursite.com/2019/06/20/%E7%BD%91%E6%98%93%E9%9B%B7%E7%81%AB%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/06/20/网易雷火运维面试记录/</id>
    <published>2019-06-20T06:12:57.000Z</published>
    <updated>2019-07-17T12:51:52.376Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="电话一面">电话一面</span></h2><ol><li><p>都搞过什么linux的发行版，区别是啥？</p></li><li><p>为什么云服务器普遍不装swap？</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小内存主机由于内存不足导致持续swapping后会严重影响存储设备的IO性能。其实如果需要使用swap的话，主机性能也已经是烂的一塌糊涂，根本不能满足使用了，建议增加内存为上。</span><br></pre></td></tr></table></figure></li><li><p>localhost与127.0.0.1的区别</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。</span><br></pre></td></tr></table></figure></li><li><p>iptables的四表五链是啥？</p></li><li><p>出现延迟都有原因？</p></li><li><p>如何把数据库恢复到指定时刻？</p></li><li><p>你从业以来参与的比较大的故障是什么？怎么解决的？</p></li><li><p>如果要大量insert数据到数据库，有什么优化的方法？</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)一条SQL语句插入多条数据:比如一次insert插入多个values，INSERT INTO `insert_table` (`datetime`, `uid`, `content`, `type`) VALUES (<span class="string">'0'</span>, <span class="string">'userid_0'</span>, <span class="string">'content_0'</span>, <span class="number">0</span>), (<span class="string">'1'</span>, <span class="string">'userid_1'</span>, <span class="string">'content_1'</span>, <span class="number">1</span>);</span><br><span class="line">这样的好处是减少binlog和innodb的日质量，降低了日志刷盘的频率提高效率，同时减少了网络传输的IO，这个优化效果特别明显；</span><br><span class="line"><span class="number">2</span>）把多一个insert写成一个事务，进行一个insert操作时，MySQL内部会建立一个事务，在事务内才进行真正插入处理操作。通过使用事务可以减少创建事务的消耗，所有插入都在执行后才进行提交操作；</span><br><span class="line"><span class="number">3</span>）数据按照主键有序插入，因为数据库插入时，需要维护索引数据，无序的记录会增大维护索引的成本，不过这个方法提高的并不明显；</span><br><span class="line"><span class="number">4</span>）以上方法综合使用；</span><br></pre></td></tr></table></figure></li></ol><h2><span id="电话二面">电话二面</span></h2><ol><li><p>介绍一下你自己</p></li><li><p>使用docker遇到了什么坑？</p></li><li><p>docker的网络模式有哪些？为什么不能选hosts？</p></li><li><p>服务器调整进程优先级的命令是啥？</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一般来说微服务（即一个云服务器只跑一个进程）的场景来说，这个问题很少遇到，但是实际很多公司是一个服务器（比如<span class="number">80</span>核<span class="number">160</span>G）跑多个进程，那么对后台的程序有优先级限制就要使用`nice`命令。</span><br><span class="line">Linux系统中，进程有<span class="number">-19</span>到<span class="number">19</span>这<span class="number">39</span>个优先级。<span class="number">-19</span>最优先，<span class="number">19</span>最不优先。进程的默认优先级为<span class="number">0</span>。如果希望将进程调整为最优先，则将进程的nice值设置为<span class="number">-19</span>；如果希望进程最不优先，占用最少的系统CPU时间，则将其设置为<span class="number">19</span>。</span><br><span class="line"></span><br><span class="line">修改已经存在的进程的优先级</span><br><span class="line">将PID为<span class="number">1799</span>的进程优先级设置为最低（<span class="number">19</span>）：renice <span class="number">19</span> <span class="number">1799</span></span><br><span class="line">将PID为<span class="number">1799</span>的进程优先级设置为最高（<span class="number">-19</span>）：renice <span class="number">-19</span> <span class="number">1799</span></span><br><span class="line"></span><br><span class="line">新建进程并设置优先级</span><br><span class="line">nice <span class="number">-19</span> tar zcf pack.tar.gz documents<span class="comment">#这里-19并不是最高优先级，而是最低优先级，要设定最高优先级是--19</span></span><br></pre></td></tr></table></figure></li><li><p>python的==和is有什么不同？</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">is</span>比较的是id是不是一样，==比较的是值是不是一样。</span><br></pre></td></tr></table></figure></li><li><p>如何删除某文件下所有名称带有空格的文件？</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以通过转义符，或者获取文件的inode，根据inode删除对应的文件:find -inum 编号 -delete</span><br><span class="line">比如想rm文件名为“my file”的文件可以用rm my\ file</span><br></pre></td></tr></table></figure></li><li><p>ansibleplaybook的回滚方法？</p></li><li><p>如果nginx的server设置了add header，同时子location也设置了add header，那么会有什么现象？</p></li><li><p>如何判断查询是否用到了索引？</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用explain，如果type类型是all就是没有用到索引，如果是其他具体类型就是用到了索引。</span><br><span class="line">索引依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引。</span><br></pre></td></tr></table></figure></li></ol><h2><span id="现场技术一面">现场技术一面</span></h2><ol><li><p>写一下Python序列循环移位的方法，原来是[1,2,3,4,5,6]，变成[3,4,5,6,1,2]，任意语言都可以。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用切片，简单易理解，速度最快，可同时实现循环左移（k&gt;<span class="number">0</span>）和右移（k&lt;<span class="number">0</span>）。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(lst, k)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> lst[k:] + lst[:k]</span><br></pre></td></tr></table></figure></li><li><p>你们平时备份mysql使用什么方法？为什么用这个开源软件？</p></li><li><p>服务器你们是如何初始化的？</p></li><li><p>简单的介绍一下python的生成器？</p></li><li><p>如果发现慢sql你怎么排查？</p></li><li><p>发现java服务出现了CPU飙升的现象，怎么排查？</p></li><li><p>除了代码问题之外，都有哪些情况会导致CPU 100%？</p></li><li><p>都做过什么优化？（主动运维方向）</p></li></ol><p>剩下的就是一些流程性的问题了。</p>]]></content>
    
    <summary type="html">
    
      这个世界总会有一些莫名其妙的拒绝
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>XtraBackup的安装和使用</title>
    <link href="http://yoursite.com/2019/06/17/XtraBackup%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/06/17/XtraBackup的安装和使用/</id>
    <published>2019-06-17T02:37:56.000Z</published>
    <updated>2019-06-17T12:56:31.275Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>XtraBackup是数据库物理备份工具，是阿里云RDS备份数据库的组件。它的优点是热备而且速度快，效率比mysqldump不知道高到哪里去了。它的备份原理如下:</p><ol><li>innobackupex首先会启动一个xtrabackup_log后台检测的进程，实时检测mysql的redo log的变化，一旦发现redo有新的日志写入，立刻将日志写入到日志文件xtrabackup_log中。</li><li>物理拷贝innodb的数据文件和系统表空间文件idbdata1到对应的以默认时间戳为备份目录的地方</li><li>复制结束后，执行<code>flush table with read lock</code>操作进行全库锁表准备备份非InnoDB文件</li><li>复制.frm .myd .myi等非InnoDB引擎文件</li><li>查看binary log 的位置</li><li>解锁unlock tables</li><li>停止xtrabackup_log进程</li></ol><p><img src="/images/xtrabackup2.png" alt="akb48"></p><h2><span id="安装与全量备份">安装与全量备份</span></h2><p>先去<a href="https://www.percona.com/downloads/Percona-XtraBackup-2.4/LATEST/" target="_blank" rel="noopener">https://www.percona.com/downloads/Percona-XtraBackup-2.4/LATEST/</a> 下载2.4版本的XtraBackup，虽然最新的版本是<code>8.0.6</code>，但是据说它只支持mysql8.0和percona8.0…<br><img src="/images/xtrabackup.png" alt="akb48"></p><p>安装步骤如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@share ~]<span class="comment">#yum install -y cmake libaio-devel</span></span><br><span class="line">[root@share ~]<span class="comment">#yum install glibc glibc-devel glibc-static</span></span><br><span class="line">[root@share ~]<span class="comment"># rpm -ivh percona-xtrabackup-24-2.4.14-1.el6.x86_64.rpm </span></span><br><span class="line">warning: percona-xtrabackup<span class="number">-24</span><span class="number">-2.4</span><span class="number">.14</span><span class="number">-1.</span>el6.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID <span class="number">8507</span>efa5: NOKEY</span><br><span class="line">Preparing...                          <span class="comment">################################# [100%]</span></span><br><span class="line">Updating / installing...</span><br><span class="line">   <span class="number">1</span>:percona-xtrabackup<span class="number">-24</span><span class="number">-2.4</span><span class="number">.14</span><span class="number">-1.</span>el<span class="comment">################################# [100%]</span></span><br><span class="line">[root@share ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>安装完毕之后，就可以<code>innobackupex --host=127.0.0.1 --user=root --password=数据库密码 --defaults-file=/etc/mysql/my.cnf /备份的文件夹名</code>来备份数据库。同时备份结束之后会生成一个LSN号，在增量备份时候，就只备份大于此号的数据页。</p><p>如果有了备份文件想要全量恢复的话，就是如下操作：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp -r /backup/备份文件夹/ 另一个mysqlIP:/backup/<span class="comment">#先将本机的备份文件夹拷贝到其他服务器里去</span></span><br><span class="line">innobackupex --apply-log --use-memory=<span class="number">1</span>G /backup/备份文件夹/<span class="comment">#在新的mysql里进行数据的准备工作，这一步用来合成可用的数据，--use-memory根据实际情况指定</span></span><br><span class="line">systemctl stop mariadb</span><br><span class="line">rm -rf /var/lib/mysql/*<span class="comment">#停止当前进程，并且删除数据目录和对应日志</span></span><br><span class="line">innobackupex --datadir=/var/lib/mysql --copy-back /backup/备份文件夹/<span class="comment">#将准备好的数据还原到对应目录里</span></span><br><span class="line">chown -R mysql: /var/lib/mysql/<span class="comment">#将文件夹属主和组都更改成mysql</span></span><br><span class="line">systemctl start mariadb<span class="comment">#重启进程</span></span><br></pre></td></tr></table></figure></p><h2><span id="增量备份与恢复">增量备份与恢复</span></h2><p>增量备份的前提是全量备份，假设我们已经进行了全量备份。增量备份过程如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">innobackupex -p数据库密码 --incremental /全量备份文件夹 --incremental-basedir=/backup/增量备份文件夹<span class="number">1</span>/<span class="comment">#与全量备份文件夹相比，进行增量备份</span></span><br><span class="line">scp -r /backup/* 另一个mysqlIP:/backup/<span class="comment">#传递给另个mysql里</span></span><br><span class="line">innobackupex --apply-log --redo-only --use-memory=<span class="number">1</span>G /backup/全量备份文件夹/<span class="comment">#先对最早的全量备份进行恢复</span></span><br><span class="line">innobackupex --apply-log --redo-only --use-memory=<span class="number">1</span>G /backup/全量备份文件夹/ --incremental-dir=/backup/增量备份文件夹<span class="number">1</span></span><br><span class="line"><span class="comment">#在之前全量备份的基础上合并一波增量备份</span></span><br><span class="line">systemctl stop mariadb</span><br><span class="line">rm -rf /var/lib/mysql/*<span class="comment">#停止当前进程，并且删除数据目录和对应日志</span></span><br><span class="line">innobackupex --datadir=/var/lib/mysql --copy-back /backup/备份文件夹/<span class="comment">#将准备好的数据还原到对应目录里</span></span><br><span class="line">chown -R mysql: /var/lib/mysql/<span class="comment">#将文件夹属主和组都更改成mysql</span></span><br><span class="line">systemctl start mariadb<span class="comment">#重启进程</span></span><br></pre></td></tr></table></figure></p><p>查看是否是增量备份还是全量备份，可以通过<code>xtrabackup_checkpoints</code>文件里的<code>backup_type</code>字段：<code>full-prepared</code>是全量备份、<code>incremental</code>是增量备份。    </p><h2><span id="mysql如何恢复到任意时间点">Mysql如何恢复到任意时间点</span></h2><p>众所周知，mysql的更新操作（UPDATE）是“先备份再覆盖”的一个过程，那备份在哪里呢?<code>buffer</code>。</p><p>但是这个瞬间就会出现buffer的数据页与磁盘的数据页内容不一致，这时的buffer的数据页叫<code>dirty page</code>。如果此时出现了mysql非正常宕机，就会出现“数据并没有同步到磁盘文件中，而且已经从内存里出来了”的现象，即数据丢失。</p><p>为了解决这个现象，就在buffer的<code>dirty page</code>变更结束之后，把相应修改记录记录到<code>redo log</code>里。如果在发现有数据丢失的现象，可以通过<code>redo log</code>回溯。更多内容可以看<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjMyMjUzNg==&amp;mid=2448131616&amp;idx=1&amp;sn=5af80b03adef5846b7dc51015d99f7e7&amp;scene=0#wechat_redirect&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5NjMyMjUzNg==&amp;mid=2448131616&amp;idx=1&amp;sn=5af80b03adef5846b7dc51015d99f7e7&amp;scene=0#wechat_redirect&amp;rd2werd=1#wechat_redirect</a> 这篇文章。</p><p>整理一下mysql里更新语句的内幕：</p><p>系统当取到一个UPDATE语句的时候，会先通过主键找到该行，判断此行是否在buffer里，如果在就直接返回给执行器，如果不在就先从磁盘拷贝一份到内存里，在内存里对数据进行修改，此时生成了<code>dirty page</code>，同时也将这个操作记录更新到<code>redo log</code>里，<code>redo log</code>处于<code>prepare</code>状态（mysql生成<code>xid</code>)，通知执行器可以提交覆盖磁盘（这是一个事务）。然后执行器先生成这个操作的bin log（mysql是<code>日志先行</code>的设计），然后再执行覆盖的农作（将<code>xid</code>写进<code>bin log</code>)。至此更新完成。</p><p>假设此时mysql出现了非正常宕机，那么先找一下有没有之前的xtrabackup等工具保留的备份，如果有当日的备份，再结合<code>bin log</code>可以恢复一个临时表。然后扫描最后一个<code>bin log</code>，提取出xid。重做检查点以后的<code>redo log</code>，搜集处于<code>prepare</code>阶段的事务链表，将事务的<code>xid</code>与<code>bin log</code>中的<code>xid</code>对比。若存在，说明事务记录到<code>bin log</code>成功，但是最终未<code>commit</code>成功，则提交，否则就回滚。</p><h2><span id="参考文档">参考文档</span></h2><p><a href="http://mysql.taobao.org/monthly/2016/03/07/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2016/03/07/</a><br><a href="http://mysql.taobao.org/monthly/2018/02/05/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/02/05/</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjMyMjUzNg==&amp;mid=2448131616&amp;idx=1&amp;sn=5af80b03adef5846b7dc51015d99f7e7&amp;scene=0#wechat_redirect&amp;rd2werd=1#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5NjMyMjUzNg==&amp;mid=2448131616&amp;idx=1&amp;sn=5af80b03adef5846b7dc51015d99f7e7&amp;scene=0#wechat_redirect&amp;rd2werd=1#wechat_redirect</a><br><a href="https://help.aliyun.com/knowledge_detail/41738.html?spm=a2c4g.11186631.2.4.2b9d6998v5nwaK" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/41738.html?spm=a2c4g.11186631.2.4.2b9d6998v5nwaK</a></p>]]></content>
    
    <summary type="html">
    
      java 8-alpine这个镜像好像不带有/etc/localtime这个文件，这样可能日志时间会相差8小时，可以修改jar包来指定区域来解决问题。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="数据备份" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
</feed>
